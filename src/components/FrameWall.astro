---
type WallImage = { src: string; alt?: string; candidates?: string[] };

const { images, seed = "wall" } = Astro.props as {
  images: WallImage[];
  seed?: string;
};

// Deterministic random (for tiny tilts only)
function xmur3(str: string) {
  let h = 1779033703 ^ str.length;
  for (let i = 0; i < str.length; i++) {
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function () {
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    return (h ^= h >>> 16) >>> 0;
  };
}
function mulberry32(a: number) {
  return function () {
    let t = (a += 0x6d2b79f5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    t = t ^ (t >>> 14);
    return (t >>> 0) / 4294967296;
  };
}

const seedFn = xmur3(seed);
const rand = mulberry32(seedFn());
const r = (min: number, max: number) => min + rand() * (max - min);

// Cover fixed center
const COVER = { cStart: 4, cSpan: 6, rStart: 1, rSpan: 46 };

// Packed slots around it (tight wall)
const SLOTS = [
  { cStart: 1,  cSpan: 3, rStart: 1,  rSpan: 16, shape: "rect" },
  { cStart: 1,  cSpan: 3, rStart: 17, rSpan: 16, shape: "rect" },
  { cStart: 1,  cSpan: 3, rStart: 33, rSpan: 14, shape: "soft" },

  { cStart: 10, cSpan: 3, rStart: 1,  rSpan: 16, shape: "rect" },
  { cStart: 10, cSpan: 3, rStart: 17, rSpan: 16, shape: "round" },
  { cStart: 10, cSpan: 3, rStart: 33, rSpan: 14, shape: "soft" },

  { cStart: 1,  cSpan: 4, rStart: 47, rSpan: 20, shape: "rect" },
  { cStart: 5,  cSpan: 4, rStart: 47, rSpan: 20, shape: "soft" },
  { cStart: 9,  cSpan: 4, rStart: 47, rSpan: 20, shape: "rect" },

  { cStart: 3,  cSpan: 4, rStart: 67, rSpan: 18, shape: "round" },
  { cStart: 7,  cSpan: 6, rStart: 67, rSpan: 18, shape: "rect" },
];

const frames = images.map((img, i) => {
  const isCover = i === 0;
  const slot = !isCover ? SLOTS[(i - 1) % SLOTS.length] : null;

  const rot = isCover ? r(-0.6, 0.6) : r(-1.1, 1.1);

  return {
    ...img,
    idx: i,
    isCover,
    rot,
    cStart: isCover ? COVER.cStart : (slot?.cStart ?? 1),
    cSpan:  isCover ? COVER.cSpan  : (slot?.cSpan ?? 3),
    rStart: isCover ? COVER.rStart : (slot?.rStart ?? 1),
    rSpan:  isCover ? COVER.rSpan  : (slot?.rSpan ?? 18),
    shape:  isCover ? "" : (slot?.shape ?? "rect"),
    delay: i * 60,
  };
});

const isSingle = frames.length === 1;
const isPair = frames.length === 2;
---

<div class={`framewall ${isSingle ? "framewall--single" : ""} ${isPair ? "framewall--pair" : ""}`} data-pair-layout="stack">
  <!-- dummy target for closing -->
  <span id="lb-close" class="lb-close-target" aria-hidden="true"></span>

  <div class="wall" aria-label="Bức tường ảnh">
    {frames.map((f) => (
      <a
        href={`#lb-${f.idx}`}
        class={`frame ${f.isCover ? "is-cover" : ""} ${f.shape ? "shape-" + f.shape : ""}`}
        style={isSingle || isPair
          ? `--rot:${isPair ? 0 : f.rot}deg; --delay:${f.delay}ms;`
          : `grid-column:${f.cStart} / span ${f.cSpan}; grid-row:${f.rStart} / span ${f.rSpan}; --rot:${f.rot}deg; --delay:${f.delay}ms;`
        }
        data-reveal
        aria-label={`Open photo ${f.idx + 1}`}
      >
        <div class="frame-inner">
          <div class="mat">
            <img
              src={f.src}
              alt={f.alt ?? ""}
              loading="lazy"
              decoding="async"
              data-candidates={f.candidates?.join("|")}
              data-candidate-index="0"
            />
          </div>
        </div>
      </a>
    ))}
  </div>

  <!-- LIGHTBOX PER IMAGE (CSS :target => always works, even with view transitions) -->
  {frames.map((f) => {
    const prev = (f.idx - 1 + frames.length) % frames.length;
    const next = (f.idx + 1) % frames.length;

    return (
      <div class="lb" id={`lb-${f.idx}`} aria-label="Image viewer">
        <a class="lb-backdrop" href="#lb-close" aria-label="Close"></a>

        <div class="lb-panel" role="dialog" aria-modal="true">
          <a class="lb-x" href="#lb-close" aria-label="Close">×</a>

          <a class="lb-nav lb-prev" href={`#lb-${prev}`} aria-label="Previous">‹</a>

          <div class="lb-frame">
            <img
              class="lb-img"
              src={f.src}
              alt={f.alt ?? ""}
              decoding="async"
              data-candidates={f.candidates?.join("|")}
              data-candidate-index="0"
            />
          </div>

          <a class="lb-nav lb-next" href={`#lb-${next}`} aria-label="Next">›</a>

          <div class="lb-meta">
            <span class="lb-count">{f.idx + 1} / {frames.length}</span>
            <a class="lb-open" href={f.src} target="_blank" rel="noreferrer">Open original</a>
          </div>

          <!-- “Slider” thumbnail strip (scroll horizontally on mobile) -->
          <div class="lb-thumbs" aria-label="Thumbnails">
            {frames.map((t) => (
              <a class={`lb-thumb ${t.idx === f.idx ? "is-active" : ""}`} href={`#lb-${t.idx}`} aria-label={`Go to ${t.idx + 1}`}>
                <img
                  src={t.src}
                  alt=""
                  loading="lazy"
                  decoding="async"
                  data-candidates={t.candidates?.join("|")}
                  data-candidate-index="0"
                />
              </a>
            ))}
          </div>
        </div>
      </div>
    );
  })}

  <style>
    /* Make sure wall is clickable */
    .framewall{ position: relative; z-index: 30; }
    .wall{ pointer-events: auto; }

    /* Packed wall */
    .wall{
      position: relative;
      display: grid;
      grid-template-columns: repeat(12, minmax(0, 1fr));
      grid-auto-rows: 10px;
      grid-auto-flow: dense;
      gap: 8px;
      padding: 10px;

      border-radius: 22px;
      background: rgba(0,0,0,0.16);
      border: 1px solid rgba(255,255,255,0.06);
      backdrop-filter: blur(8px);
      box-shadow: 0 22px 70px rgba(0,0,0,0.45);
    }

    .framewall--single .wall{
      display: block;
      padding: 12px;
    }

    .framewall--pair .wall{
      grid-template-columns: 1fr;
      grid-auto-rows: minmax(260px, auto);
      gap: 12px;
      padding: 12px;
    }

    .framewall--pair[data-pair-layout="side"] .wall{
      grid-template-columns: repeat(2, minmax(0, 1fr));
      grid-auto-rows: minmax(220px, 1fr);
    }

    .framewall--pair .frame{
      transform: none;
    }

    .framewall--pair .frame:hover{
      transform: none;
      filter: none;
    }

    .framewall--pair .frame-inner,
    .framewall--pair .mat{
      height: 100%;
    }

    .framewall--pair .mat img{
      object-fit: contain;
      background: rgba(0,0,0,0.2);
    }

    .framewall--single .frame{
      transform: none;
      height: auto;
    }

    .framewall--single .frame:hover{
      transform: none;
      filter: none;
    }

    .framewall--single .frame-inner,
    .framewall--single .mat{
      height: auto;
    }

    .framewall--single .mat img{
      height: auto;
      object-fit: contain;
    }

    @media (max-width: 640px){
      .wall{
        grid-template-columns: repeat(6, minmax(0, 1fr));
        grid-auto-rows: 9px;
        gap: 7px;
        padding: 8px;
      }
      .frame{ grid-column: span 3 !important; grid-row: span 18 !important; }
      .frame.is-cover{ grid-column: 1 / -1 !important; grid-row: span 30 !important; }
      .framewall--single .frame{ grid-column: auto !important; grid-row: auto !important; }
      .framewall--pair .wall{ grid-template-columns: 1fr; grid-auto-rows: minmax(220px, auto); }
      .framewall--pair .frame{ grid-column: auto !important; grid-row: auto !important; }
    }

    .frame{
      display:block;
      width: 100%;
      height: 100%;
      text-decoration: none;
      transform: rotate(var(--rot, 0deg));
      transition: transform 220ms ease, filter 220ms ease;
      border-radius: 18px;
      pointer-events: auto;
    }
    .frame:hover{
      transform: rotate(calc(var(--rot, 0deg) * 0.55)) scale(1.01);
      filter: saturate(1.03);
    }
    .frame:focus-visible{
      outline: 2px dashed rgba(212,176,106,0.55);
      outline-offset: 6px;
    }

    /* European renaissance frame (richer gold + ornament) */
    .frame-inner{
      position: relative;
      height: 100%;
      width: 100%;
      padding: 7px;
      border-radius: 18px;
      overflow: hidden;

      background:
        linear-gradient(180deg, rgba(255,233,170,0.22), rgba(94,66,28,0.35)),
        linear-gradient(90deg, rgba(48,32,12,0.4), rgba(255,230,168,0.25), rgba(48,32,12,0.4));

      border: 1px solid rgba(214,184,118,0.38);
      box-shadow:
        0 18px 46px rgba(0,0,0,0.45),
        0 1px 0 rgba(255,214,128,0.28) inset;
    }

    .frame-inner::before{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      opacity: 0.35;
      mix-blend-mode: overlay;
      background-image: url("data:image/svg+xml,%3Csvg%20xmlns%3D%27http%3A//www.w3.org/2000/svg%27%20width%3D%27120%27%20height%3D%27120%27%20viewBox%3D%270%200%20120%20120%27%3E%3Cg%20fill%3D%27none%27%20stroke%3D%27%23d4b06a%27%20stroke-opacity%3D%270.55%27%20stroke-width%3D%272%27%3E%3Cpath%20d%3D%27M60%2010c-9%2010-14%2018-14%2028%200%2010%206%2016%2014%2016s14-6%2014-16c0-10-5-18-14-28z%27/%3E%3Cpath%20d%3D%27M60%20110c9-10%2014-18%2014-28%200-10-6-16-14-16s-14%206-14%2016c0%2010%205%2018%2014%2028z%27/%3E%3Cpath%20d%3D%27M10%2060c10-9%2018-14%2028-14%2010%200%2016%206%2016%2014s-6%2014-16%2014c-10%200-18-5-28-14z%27/%3E%3Cpath%20d%3D%27M110%2060c-10%209-18%2014-28%2014-10%200-16-6-16-14s6-14%2016-14c10%200%2018%205%2028%2014z%27/%3E%3Ccircle%20cx%3D%2760%27%20cy%3D%2760%27%20r%3D%276%27%20stroke-opacity%3D%270.35%27/%3E%3C/g%3E%3C/svg%3E");
      background-size: 140px 140px;
      background-repeat: repeat;
    }

    .frame-inner::after{
      content:"";
      position:absolute;
      inset: 4px;
      border-radius: 16px;
      pointer-events:none;
      border: 1px solid rgba(76,44,12,0.35);
      box-shadow:
        0 0 0 1px rgba(255,222,160,0.18) inset,
        0 0 18px rgba(212,176,106,0.22);
      opacity: 0.75;
    }

    .mat{
      height: 100%;
      width: 100%;
      border-radius: 14px;
      overflow: hidden;
      background: rgba(0,0,0,0.12);
      border: 1px solid rgba(255,255,255,0.05);
      position: relative;
      z-index: 1;
    }
    .mat img{ width:100%; height:100%; object-fit: cover; display:block; }

    .shape-round .mat{ border-radius: 999px; }
    .shape-soft .mat{ border-radius: 22px; }

    /* -------- LIGHTBOX (CSS :target) -------- */
    .lb{ position: fixed; inset:0; z-index: 9999; opacity:0; pointer-events:none; transition: opacity 160ms ease; }
    .lb:target{ opacity:1; pointer-events:auto; }

    .lb-backdrop{
      position:absolute; inset:0;
      background: rgba(0,0,0,0.72);
      backdrop-filter: blur(10px);
    }

    .lb-panel{
      position: relative;
      width: min(980px, 96vw);
      max-height: 90vh;
      margin: 0 auto;
      top: 50%;
      transform: translateY(-50%);
      display: grid;
      grid-template-columns: 56px 1fr 56px;
      gap: 12px;
      align-items: center;
      padding: 10px;
    }
    @media (max-width: 640px){
      .lb-panel{ grid-template-columns: 44px 1fr 44px; }
    }

    .lb-x{
      position:absolute;
      top: -10px;
      right: -10px;
      width: 40px; height: 40px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.35);
      color: rgba(255,255,255,0.92);
      font-size: 22px;
      display:grid;
      place-items:center;
      text-decoration:none;
      z-index: 2;
    }

    .lb-nav{
      width: 56px; height: 56px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.35);
      color: rgba(255,255,255,0.92);
      font-size: 34px;
      display:grid;
      place-items:center;
      text-decoration:none;
      z-index: 2;
      user-select: none;
    }
    @media (max-width: 640px){
      .lb-nav{ width: 44px; height: 44px; font-size: 28px; }
    }

    .lb-frame{
      border-radius: 18px;
      padding: 10px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 26px 90px rgba(0,0,0,0.65);
      backdrop-filter: blur(8px);
      overflow: hidden;
      touch-action: pan-x; /* allow swipe scroll on thumbs */
    }

    .lb-img{
      width: 100%;
      max-height: 72vh;
      height: auto;
      object-fit: contain;
      display:block;
      border-radius: 12px;
    }

    .lb-meta{
      grid-column: 1 / -1;
      display:flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin-top: 10px;
      color: rgba(255,255,255,0.75);
    }
    .lb-open, .lb-count{
      font-size: 12px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 6px 10px;
      border-radius: 999px;
      text-decoration:none;
      color: rgba(255,255,255,0.78);
      backdrop-filter: blur(8px);
    }

    /* thumbnail "slider" strip */
    .lb-thumbs{
      grid-column: 1 / -1;
      margin-top: 10px;
      display: flex;
      gap: 8px;
      overflow-x: auto;
      padding: 8px 4px;
      scroll-snap-type: x mandatory;
      -webkit-overflow-scrolling: touch;
    }
    .lb-thumb{
      flex: 0 0 auto;
      width: 64px;
      height: 46px;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.25);
      scroll-snap-align: start;
      opacity: 0.75;
      text-decoration:none;
    }
    .lb-thumb img{
      width:100%; height:100%;
      object-fit: cover;
      display:block;
      filter: saturate(0.95) contrast(1.05);
    }
    .lb-thumb.is-active{
      opacity: 1;
      border-color: rgba(212,176,106,0.35);
      box-shadow: 0 10px 30px rgba(0,0,0,0.45);
    }

    /* hide dummy close target */
    .lb-close-target{ position: fixed; width:1px; height:1px; left:-9999px; top:-9999px; }
  </style>

  <script>
    import heic2any from "heic2any";

    const resolvePairLayouts = () => {
      const walls = document.querySelectorAll(".framewall--pair");
      walls.forEach((wall) => {
        if (!(wall instanceof HTMLElement)) return;
        const pairImages = Array.from(wall.querySelectorAll<HTMLImageElement>(".wall > .frame .mat img")).slice(0, 2);
        if (pairImages.length < 2) return;

        const readyImages = pairImages.filter((img) => img.naturalWidth > 0 && img.naturalHeight > 0);
        if (readyImages.length < 2) return;

        const ratios = readyImages.map((img) => img.naturalWidth / img.naturalHeight);
        const allLandscape = ratios.every((ratio) => ratio > 1.05);
        wall.dataset.pairLayout = allLandscape ? "stack" : "side";
      });
    };

    const initFallbacks = () => {
      const images = document.querySelectorAll("img[data-candidates]");
      images.forEach((img) => {
        if (!(img instanceof HTMLImageElement)) return;
        if (!img.dataset.candidateIndex) {
          img.dataset.candidateIndex = "0";
        }
      });
      void primeHeicFallbacks();
    };

    const HEIC_RE = /\.(heic|heif)(?:[?#].*)?$/i;
    const convertedImageUrlCache = new Map();
    const NON_SAFARI_RE = /(chrome|crios|edg|opr|android)/i;

    const srcWithAbsUrl = (value: string): string => {
      try {
        return new URL(value, window.location.origin).toString();
      } catch (_error) {
        return value;
      }
    };

    const nextCandidate = (img: HTMLImageElement): string | null => {
      const raw = img.dataset.candidates;
      if (!raw) return null;
      const candidates = raw.split("|").filter(Boolean);
      const nextIndex = Number(img.dataset.candidateIndex ?? "0") + 1;
      if (nextIndex >= candidates.length) return null;
      img.dataset.candidateIndex = String(nextIndex);
      return candidates[nextIndex];
    };

    const blobIsRenderable = async (blob: Blob): Promise<boolean> => {
      if (!(blob instanceof Blob) || blob.size <= 0) return false;
      let bitmap = null;
      if ("createImageBitmap" in window) {
        try {
          bitmap = await createImageBitmap(blob);
        } catch (_error) {
          bitmap = null;
        }
      }

      if (bitmap && bitmap.width > 1 && bitmap.height > 1) {
        try {
          const sampleW = Math.max(1, Math.min(64, bitmap.width));
          const sampleH = Math.max(1, Math.min(64, bitmap.height));
          const canvas = document.createElement("canvas");
          canvas.width = sampleW;
          canvas.height = sampleH;
          const ctx = canvas.getContext("2d", { willReadFrequently: true });
          if (ctx) {
            ctx.drawImage(bitmap, 0, 0, sampleW, sampleH);
            const data = ctx.getImageData(0, 0, sampleW, sampleH).data;
            const pxCount = sampleW * sampleH;
            let alphaSum = 0;
            let lumSum = 0;
            let lumSqSum = 0;
            for (let i = 0; i < data.length; i += 4) {
              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];
              const a = data[i + 3];
              alphaSum += a;
              const lum = 0.2126 * r + 0.7152 * g + 0.0722 * b;
              lumSum += lum;
              lumSqSum += lum * lum;
            }
            const alphaAvg = alphaSum / pxCount;
            const lumAvg = lumSum / pxCount;
            const lumVar = lumSqSum / pxCount - lumAvg * lumAvg;
            // Reject transparent/flat-black decodes that appear "successful" but render as empty cards.
            if (alphaAvg > 5 && !(lumAvg < 2 && lumVar < 1)) {
              bitmap.close();
              return true;
            }
          }
        } catch (_error) {
          // fall through to Image decode check
        } finally {
          bitmap.close();
        }
      }

      const objectUrl = URL.createObjectURL(blob);
      try {
        const ok = await new Promise((resolve) => {
          const probe = new Image();
          probe.onload = () => resolve((probe.naturalWidth || 0) > 1 && (probe.naturalHeight || 0) > 1);
          probe.onerror = () => resolve(false);
          probe.src = objectUrl;
        });
        return Boolean(ok);
      } finally {
        URL.revokeObjectURL(objectUrl);
      }
    };

    const convertHeicToJpeg = async (img: HTMLImageElement): Promise<boolean> => {
      const currentSrc = srcWithAbsUrl(img.currentSrc || img.src || "");
      if (!HEIC_RE.test(currentSrc)) return false;
      if (img.dataset.heicConverted === "1") return false;
      img.dataset.heicConverted = "1";

      const cached = convertedImageUrlCache.get(currentSrc);
      if (cached) {
        img.src = cached;
        return true;
      }

      const res = await fetch(currentSrc, { credentials: "same-origin" });
      if (!res.ok) return false;
      const raw = await res.arrayBuffer();
      const sourceBytes = raw.byteLength;
      const typedBlob = new Blob([raw], {
        type: /\.heif(?:[?#].*)?$/i.test(currentSrc) ? "image/heif" : "image/heic",
      });
      const conversionTargets = [
        { toType: "image/jpeg", quality: 0.9 },
        { toType: "image/png", quality: 1 },
      ];
      for (const target of conversionTargets) {
        const converted = await heic2any({
          blob: typedBlob,
          toType: target.toType,
          quality: target.quality,
        });
        const outBlob = Array.isArray(converted) ? converted[0] : converted;
        if (!(outBlob instanceof Blob)) continue;

        // Broken HEIC decodes sometimes yield tiny unusable blobs.
        if (sourceBytes > 256 * 1024 && outBlob.size < 8 * 1024) continue;
        const renderable = await blobIsRenderable(outBlob);
        if (!renderable) continue;

        const objectUrl = URL.createObjectURL(outBlob);
        convertedImageUrlCache.set(currentSrc, objectUrl);
        img.src = objectUrl;
        return true;
      }
      return false;
    };

    const isProbablySafari = () => /safari/i.test(navigator.userAgent) && !NON_SAFARI_RE.test(navigator.userAgent);

    const primeHeicFallbacks = async () => {
      if (isProbablySafari()) return;
      const images = document.querySelectorAll("img[data-candidates]");
      for (const img of images) {
        if (!(img instanceof HTMLImageElement)) continue;
        if (img.dataset.heicPrimed === "1") continue;
        const currentSrc = srcWithAbsUrl(img.currentSrc || img.src || "");
        if (!HEIC_RE.test(currentSrc)) continue;
        img.dataset.heicPrimed = "1";
        try {
          const converted = await convertHeicToJpeg(img);
          if (converted) continue;
        } catch (_error) {
          // fallback chain below
        }
        const next = nextCandidate(img);
        if (next) img.src = next;
      }
    };

    if (!(window as any).__twawFrameWallFallbackBound) {
      document.addEventListener(
        "error",
        (event) => {
          const target = event.target;
          if (!(target instanceof HTMLImageElement)) return;
          if (!target.dataset.candidates) return;

          const run = async () => {
            try {
              const converted = await convertHeicToJpeg(target);
              if (converted) return;
            } catch (_error) {
              // fallback to candidate chain below
            }
            const next = nextCandidate(target);
            if (next) target.src = next;
          };

          void run();
        },
        true,
      );
      (window as any).__twawFrameWallFallbackBound = true;
    }

    document.addEventListener(
      "load",
      (event) => {
        if (!(event.target instanceof HTMLImageElement)) return;
        resolvePairLayouts();
      },
      true,
    );

    initFallbacks();
    resolvePairLayouts();
    document.addEventListener("astro:page-load", () => {
      initFallbacks();
      resolvePairLayouts();
    });
  </script>
</div>
