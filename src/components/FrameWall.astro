---
type WallImage = { src: string; alt?: string; candidates?: string[] };

const { images, seed = "wall" } = Astro.props as {
  images: WallImage[];
  seed?: string;
};

// Deterministic random (for tiny tilts only)
function xmur3(str: string) {
  let h = 1779033703 ^ str.length;
  for (let i = 0; i < str.length; i++) {
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function () {
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    return (h ^= h >>> 16) >>> 0;
  };
}
function mulberry32(a: number) {
  return function () {
    let t = (a += 0x6d2b79f5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    t = t ^ (t >>> 14);
    return (t >>> 0) / 4294967296;
  };
}

const seedFn = xmur3(seed);
const rand = mulberry32(seedFn());
const r = (min: number, max: number) => min + rand() * (max - min);

type LayoutSlot = {
  cStart: number;
  cSpan: number;
  rStart: number;
  rSpan: number;
  shape?: "rect" | "soft" | "round";
};

const slot = (
  cStart: number,
  cSpan: number,
  rStart: number,
  rSpan: number,
  shape?: "rect" | "soft" | "round"
): LayoutSlot => ({ cStart, cSpan, rStart, rSpan, shape });

const COVER_SLOT = slot(4, 6, 9, 28);
const SALON_RING_SLOTS: LayoutSlot[] = [
  slot(1, 3, 4, 10, "rect"),
  slot(10, 3, 4, 10, "rect"),
  slot(1, 3, 15, 10, "soft"),
  slot(10, 3, 15, 10, "soft"),
  slot(4, 2, 1, 8, "round"),
  slot(8, 2, 1, 8, "round"),
  slot(6, 2, 1, 8, "rect"),
  slot(1, 3, 26, 10, "rect"),
  slot(10, 3, 26, 10, "rect"),
  slot(4, 2, 37, 10, "soft"),
  slot(8, 2, 37, 10, "soft"),
  slot(6, 2, 37, 10, "round"),
  slot(1, 3, 37, 10, "rect"),
  slot(10, 3, 37, 10, "rect"),
  slot(4, 6, 47, 8, "soft"),
];

const layoutForCount = (count: number): LayoutSlot[] => {
  if (count <= 1) return [slot(1, 12, 1, 34)];
  if (count === 2) return [slot(1, 6, 1, 24), slot(7, 6, 1, 24)];
  return [COVER_SLOT, ...SALON_RING_SLOTS.slice(0, Math.max(0, count - 1))];
};

const SHAPE_RING: Array<"rect" | "soft" | "round"> = ["rect", "soft", "round"];
const resolvedCount = Math.max(1, Math.min(images.length, 16));
const layoutSlots = layoutForCount(resolvedCount);

const frames = images.map((img, i) => {
  const picked = layoutSlots[i] ?? layoutSlots[layoutSlots.length - 1] ?? slot(1, 12, 1, 20);
  const isCover = i === 0 && resolvedCount > 2;

  const rot = resolvedCount <= 2 ? 0 : (isCover ? r(-0.5, 0.5) : r(-0.9, 0.9));
  const shape = picked.shape ?? SHAPE_RING[i % SHAPE_RING.length] ?? "rect";

  return {
    ...img,
    initialSrc: img.candidates?.[0] ?? img.src,
    idx: i,
    isCover,
    rot,
    cStart: picked.cStart,
    cSpan: picked.cSpan,
    rStart: picked.rStart,
    rSpan: picked.rSpan,
    shape: isCover ? "" : shape,
    delay: i * 60,
  };
});

const isSingle = frames.length === 1;
const isPair = frames.length === 2;
const isCustomGrid = frames.length >= 3;
---

<div
  class={`framewall ${isSingle ? "framewall--single" : ""} ${isPair ? "framewall--pair" : ""} ${isCustomGrid ? "framewall--custom" : ""}`}
  data-pair-layout="stack"
  data-count={String(frames.length)}
>
  <!-- dummy target for closing -->
  <span id="lb-close" class="lb-close-target" aria-hidden="true"></span>

  <div class="wall" aria-label="Bức tường ảnh">
    {frames.map((f) => (
      <a
        href={`#lb-${f.idx}`}
        class={`frame ${f.isCover ? "is-cover" : ""} ${f.shape ? "shape-" + f.shape : ""}`}
        style={isSingle || isPair || isCustomGrid
          ? `--rot:${(isPair || isCustomGrid) ? 0 : f.rot}deg; --delay:${f.delay}ms;`
          : `grid-column:${f.cStart} / span ${f.cSpan}; grid-row:${f.rStart} / span ${f.rSpan}; --rot:${f.rot}deg; --delay:${f.delay}ms;`
        }
        data-reveal
        aria-label={`Open photo ${f.idx + 1}`}
      >
        <div class="frame-inner">
          <div class="mat">
            <img
              src={f.initialSrc}
              alt={f.alt ?? ""}
              loading={f.isCover ? "eager" : "lazy"}
              decoding="async"
              data-candidates={f.candidates?.join("|")}
              data-candidate-index="0"
            />
          </div>
        </div>
      </a>
    ))}
  </div>

  <!-- LIGHTBOX PER IMAGE (CSS :target => always works, even with view transitions) -->
  {frames.map((f) => {
    const prev = (f.idx - 1 + frames.length) % frames.length;
    const next = (f.idx + 1) % frames.length;

    return (
      <div
        class="lb"
        id={`lb-${f.idx}`}
        data-lb-index={String(f.idx)}
        data-lb-prev={String(prev)}
        data-lb-next={String(next)}
        aria-label="Image viewer"
      >
        <a class="lb-backdrop" href="#lb-close" aria-label="Close"></a>

        <div class="lb-panel" role="dialog" aria-modal="true">
          <a class="lb-x" href="#lb-close" aria-label="Close">×</a>

          <a class="lb-nav lb-prev" href={`#lb-${prev}`} aria-label="Previous">‹</a>

          <div class="lb-frame">
            <img
              class="lb-img"
              src={f.initialSrc}
              alt={f.alt ?? ""}
              loading="lazy"
              decoding="async"
              data-candidates={f.candidates?.join("|")}
              data-candidate-index="0"
            />
          </div>

          <a class="lb-nav lb-next" href={`#lb-${next}`} aria-label="Next">›</a>

          <div class="lb-meta">
            <span class="lb-count">{f.idx + 1} / {frames.length}</span>
            <a class="lb-open" href={f.src} target="_blank" rel="noreferrer">Open original</a>
          </div>

          <!-- “Slider” thumbnail strip (scroll horizontally on mobile) -->
          <div class="lb-thumbs" aria-label="Thumbnails">
            {frames.map((t) => (
              <a class={`lb-thumb ${t.idx === f.idx ? "is-active" : ""}`} href={`#lb-${t.idx}`} aria-label={`Go to ${t.idx + 1}`}>
                <img
                  src={t.initialSrc}
                  alt=""
                  loading="lazy"
                  decoding="async"
                  data-candidates={t.candidates?.join("|")}
                  data-candidate-index="0"
                />
              </a>
            ))}
          </div>
        </div>
      </div>
    );
  })}

  <style>
    /* Make sure wall is clickable */
    .framewall{ position: relative; z-index: 30; }
    .wall{ pointer-events: auto; }

    /* Packed wall */
    .wall{
      position: relative;
      display: grid;
      grid-template-columns: repeat(12, minmax(0, 1fr));
      grid-auto-rows: 10px;
      grid-auto-flow: dense;
      gap: 8px;
      padding: 10px;

      border-radius: 22px;
      background: rgba(0,0,0,0.16);
      border: 1px solid rgba(255,255,255,0.06);
      backdrop-filter: blur(8px);
      box-shadow: 0 22px 70px rgba(0,0,0,0.45);
    }

    .framewall--single .wall{
      display: block;
      padding: 12px;
    }

    .framewall--pair .wall{
      grid-template-columns: 1fr;
      grid-auto-rows: minmax(260px, auto);
      gap: 12px;
      padding: 12px;
    }

    .framewall--pair[data-pair-layout="side"] .wall{
      grid-template-columns: repeat(2, minmax(0, 1fr));
      grid-auto-rows: minmax(220px, 1fr);
    }

    .framewall--pair .frame{
      transform: none;
    }

    .framewall--pair .frame:hover{
      transform: none;
      filter: none;
    }

    .framewall--pair .frame-inner,
    .framewall--pair .mat{
      height: 100%;
    }

    .framewall--pair .mat img{
      object-fit: contain;
      background: rgba(0,0,0,0.2);
    }

    .framewall--custom .wall{
      grid-template-columns: 1fr;
      grid-auto-rows: auto;
      gap: 16px;
      padding: 14px;
      max-width: 920px;
      margin: 0 auto;
    }

    .framewall--custom .frame{
      transform: none;
      height: auto;
    }

    .framewall--custom .frame:hover{
      transform: none;
      filter: none;
    }

    .framewall--custom .frame-inner,
    .framewall--custom .mat{
      height: auto;
    }

    .framewall--custom .mat{
      min-height: 260px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .framewall--custom .mat img{
      width: 100%;
      height: auto;
      object-fit: contain;
      background: rgba(0,0,0,0.2);
    }

    .framewall--single .frame{
      transform: none;
      height: auto;
    }

    .framewall--single .frame:hover{
      transform: none;
      filter: none;
    }

    .framewall--single .frame-inner,
    .framewall--single .mat{
      height: auto;
    }

    .framewall--single .mat img{
      height: auto;
      object-fit: contain;
    }

    @media (max-width: 640px){
      .wall{
        grid-template-columns: repeat(12, minmax(0, 1fr));
        grid-auto-rows: 6px;
        gap: 6px;
        padding: 8px;
      }
      .framewall--single .wall{
        display: block;
        padding: 10px;
      }
      .framewall--pair .wall{
        grid-template-columns: 1fr;
        grid-auto-rows: minmax(220px, auto);
      }
      .framewall--pair[data-pair-layout="side"] .wall{
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      .framewall--custom .wall{
        grid-template-columns: 1fr;
        gap: 10px;
        padding: 10px;
        max-width: 100%;
      }

      .framewall--custom .mat{
        min-height: 200px;
      }
    }

    .frame{
      display:block;
      width: 100%;
      height: 100%;
      text-decoration: none;
      transform: rotate(var(--rot, 0deg));
      transition: transform 220ms ease, filter 220ms ease;
      border-radius: 18px;
      pointer-events: auto;
    }
    .frame:hover{
      transform: rotate(calc(var(--rot, 0deg) * 0.55)) scale(1.01);
      filter: saturate(1.03);
    }
    .frame:focus-visible{
      outline: 2px dashed rgba(212,176,106,0.55);
      outline-offset: 6px;
    }

    /* European renaissance frame (richer gold + ornament) */
    .frame-inner{
      position: relative;
      height: 100%;
      width: 100%;
      padding: 7px;
      border-radius: 18px;
      overflow: hidden;

      background:
        linear-gradient(180deg, rgba(255,233,170,0.22), rgba(94,66,28,0.35)),
        linear-gradient(90deg, rgba(48,32,12,0.4), rgba(255,230,168,0.25), rgba(48,32,12,0.4));

      border: 1px solid rgba(214,184,118,0.38);
      box-shadow:
        0 18px 46px rgba(0,0,0,0.45),
        0 1px 0 rgba(255,214,128,0.28) inset;
    }

    .frame-inner::before{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      opacity: 0.35;
      mix-blend-mode: overlay;
      background-image: url("data:image/svg+xml,%3Csvg%20xmlns%3D%27http%3A//www.w3.org/2000/svg%27%20width%3D%27120%27%20height%3D%27120%27%20viewBox%3D%270%200%20120%20120%27%3E%3Cg%20fill%3D%27none%27%20stroke%3D%27%23d4b06a%27%20stroke-opacity%3D%270.55%27%20stroke-width%3D%272%27%3E%3Cpath%20d%3D%27M60%2010c-9%2010-14%2018-14%2028%200%2010%206%2016%2014%2016s14-6%2014-16c0-10-5-18-14-28z%27/%3E%3Cpath%20d%3D%27M60%20110c9-10%2014-18%2014-28%200-10-6-16-14-16s-14%206-14%2016c0%2010%205%2018%2014%2028z%27/%3E%3Cpath%20d%3D%27M10%2060c10-9%2018-14%2028-14%2010%200%2016%206%2016%2014s-6%2014-16%2014c-10%200-18-5-28-14z%27/%3E%3Cpath%20d%3D%27M110%2060c-10%209-18%2014-28%2014-10%200-16-6-16-14s6-14%2016-14c10%200%2018%205%2028%2014z%27/%3E%3Ccircle%20cx%3D%2760%27%20cy%3D%2760%27%20r%3D%276%27%20stroke-opacity%3D%270.35%27/%3E%3C/g%3E%3C/svg%3E");
      background-size: 140px 140px;
      background-repeat: repeat;
    }

    .frame-inner::after{
      content:"";
      position:absolute;
      inset: 4px;
      border-radius: 16px;
      pointer-events:none;
      border: 1px solid rgba(76,44,12,0.35);
      box-shadow:
        0 0 0 1px rgba(255,222,160,0.18) inset,
        0 0 18px rgba(212,176,106,0.22);
      opacity: 0.75;
    }

    .mat{
      height: 100%;
      width: 100%;
      border-radius: 14px;
      overflow: hidden;
      background:
        radial-gradient(120% 90% at 20% 0%, rgba(255,255,255,0.14), rgba(0,0,0,0.08) 55%, rgba(0,0,0,0.3) 100%),
        url("/decor/wallpaper.svg");
      background-size: auto, 360px 360px;
      background-position: center, center;
      background-repeat: no-repeat, repeat;
      border: 1px solid rgba(255,255,255,0.05);
      position: relative;
      z-index: 1;
    }
    .mat img{ width:100%; height:100%; object-fit: cover; display:block; }

    .shape-round .mat{ border-radius: 999px; }
    .shape-soft .mat{ border-radius: 22px; }

    /* -------- LIGHTBOX (CSS :target) -------- */
    .lb{ position: fixed; inset:0; z-index: 9999; opacity:0; pointer-events:none; transition: opacity 160ms ease; }
    .lb:target{ opacity:1; pointer-events:auto; }

    .lb-backdrop{
      position:absolute; inset:0;
      background: rgba(0,0,0,0.72);
      backdrop-filter: blur(10px);
    }

    .lb-panel{
      position: relative;
      width: min(980px, 96vw);
      max-height: 90vh;
      margin: 0 auto;
      top: 50%;
      transform: translateY(-50%);
      display: grid;
      grid-template-columns: 56px 1fr 56px;
      gap: 12px;
      align-items: center;
      padding: 10px;
    }
    @media (max-width: 640px){
      .lb-panel{ grid-template-columns: 44px 1fr 44px; }
    }

    .lb-x{
      position:absolute;
      top: -10px;
      right: -10px;
      width: 40px; height: 40px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.35);
      color: rgba(255,255,255,0.92);
      font-size: 22px;
      display:grid;
      place-items:center;
      text-decoration:none;
      z-index: 2;
    }

    .lb-nav{
      width: 56px; height: 56px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.35);
      color: rgba(255,255,255,0.92);
      font-size: 34px;
      display:grid;
      place-items:center;
      text-decoration:none;
      z-index: 2;
      user-select: none;
    }
    @media (max-width: 640px){
      .lb-nav{ width: 44px; height: 44px; font-size: 28px; }
    }

    .lb-frame{
      border-radius: 18px;
      padding: 10px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 26px 90px rgba(0,0,0,0.65);
      backdrop-filter: blur(8px);
      overflow: hidden;
      touch-action: pan-x; /* allow swipe scroll on thumbs */
    }

    .lb-img{
      width: 100%;
      max-height: 72vh;
      height: auto;
      object-fit: contain;
      display:block;
      border-radius: 12px;
    }

    .lb-meta{
      grid-column: 1 / -1;
      display:flex;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 10px;
      color: rgba(255,255,255,0.75);
    }
    .lb-open, .lb-count{
      font-size: 12px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 6px 10px;
      border-radius: 999px;
      text-decoration:none;
      color: rgba(255,255,255,0.78);
      backdrop-filter: blur(8px);
    }

    @media (max-width: 640px){
      .lb-meta{
        gap: 8px;
      }

      .lb-open, .lb-count{
        font-size: 10px;
        padding: 5px 8px;
      }
    }

    /* thumbnail "slider" strip */
    .lb-thumbs{
      grid-column: 1 / -1;
      margin-top: 10px;
      display: flex;
      gap: 8px;
      overflow-x: auto;
      padding: 8px 4px;
      scroll-snap-type: x mandatory;
      -webkit-overflow-scrolling: touch;
    }
    .lb-thumb{
      flex: 0 0 auto;
      width: 64px;
      height: 46px;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.25);
      scroll-snap-align: start;
      opacity: 0.75;
      text-decoration:none;
    }
    .lb-thumb img{
      width:100%; height:100%;
      object-fit: cover;
      display:block;
      filter: saturate(0.95) contrast(1.05);
    }
    .lb-thumb.is-active{
      opacity: 1;
      border-color: rgba(212,176,106,0.35);
      box-shadow: 0 10px 30px rgba(0,0,0,0.45);
    }

    /* hide dummy close target */
    .lb-close-target{ position: fixed; width:1px; height:1px; left:-9999px; top:-9999px; }
  </style>

  <script>
    const resolvePairLayouts = () => {
      const walls = document.querySelectorAll(".framewall--pair");
      walls.forEach((wall) => {
        if (!(wall instanceof HTMLElement)) return;
        const pairImages = Array.from(wall.querySelectorAll<HTMLImageElement>(".wall > .frame .mat img")).slice(0, 2);
        if (pairImages.length < 2) return;

        const readyImages = pairImages.filter((img) => img.naturalWidth > 0 && img.naturalHeight > 0);
        if (readyImages.length < 2) return;

        const ratios = readyImages.map((img) => img.naturalWidth / img.naturalHeight);
        const allLandscape = ratios.every((ratio) => ratio > 1.05);
        wall.dataset.pairLayout = allLandscape ? "stack" : "side";
      });
    };

    const HEIC_RE = /\.(heic|heif)(?:[?#].*)?$/i;
    const NON_SAFARI_RE = /(chrome|crios|edg|opr|android)/i;
    const convertedImageUrlCache = new Map<string, string>();
    const heicConvertResultCache = new Map<string, boolean>();
    const candidateProbeResultCache = new Map<string, boolean>();
    const candidateProbePromiseCache = new Map<string, Promise<boolean>>();
    let heic2anyLoader: Promise<any> | null = null;

    const loadHeic2any = async () => {
      if (!heic2anyLoader) {
        heic2anyLoader = import("heic2any").then((mod) => mod.default ?? mod);
      }
      return heic2anyLoader;
    };

    const isProbablySafari = () =>
      /safari/i.test(navigator.userAgent) && !NON_SAFARI_RE.test(navigator.userAgent);

    const srcWithAbsUrl = (value: string): string => {
      try {
        return new URL(value, window.location.origin).toString();
      } catch (_error) {
        return value;
      }
    };

    const parseCandidates = (img: HTMLImageElement) => {
      const raw = img.dataset.candidates ?? "";
      const candidates = raw.split("|").filter(Boolean);
      const indexRaw = Number.parseInt(img.dataset.candidateIndex ?? "0", 10);
      const index = Number.isNaN(indexRaw)
        ? 0
        : Math.max(0, Math.min(indexRaw, Math.max(candidates.length - 1, 0)));
      return { candidates, index };
    };

    const setCandidate = (img: HTMLImageElement, index: number, next: string) => {
      img.dataset.candidateIndex = String(index);
      if (img.getAttribute("src") !== next) {
        img.src = next;
      }
    };

    const probeCandidate = async (value: string): Promise<boolean> => {
      const abs = srcWithAbsUrl(value);
      const cached = candidateProbeResultCache.get(abs);
      if (typeof cached === "boolean") return cached;
      const inFlight = candidateProbePromiseCache.get(abs);
      if (inFlight) return inFlight;

      const promise = new Promise<boolean>((resolve) => {
        const probe = new Image();
        let settled = false;
        const done = (ok: boolean) => {
          if (settled) return;
          settled = true;
          candidateProbeResultCache.set(abs, ok);
          candidateProbePromiseCache.delete(abs);
          resolve(ok);
        };
        const timeout = window.setTimeout(() => done(false), 8000);
        probe.onload = () => {
          window.clearTimeout(timeout);
          done((probe.naturalWidth || 0) > 1 && (probe.naturalHeight || 0) > 1);
        };
        probe.onerror = () => {
          window.clearTimeout(timeout);
          done(false);
        };
        probe.src = abs;
      });

      candidateProbePromiseCache.set(abs, promise);
      return promise;
    };

    const findWorkingCandidate = async (
      img: HTMLImageElement,
      startIndex: number,
      { skipHeic }: { skipHeic: boolean }
    ): Promise<boolean> => {
      const { candidates } = parseCandidates(img);
      if (!candidates.length) return false;
      for (let i = Math.max(0, startIndex); i < candidates.length; i += 1) {
        const candidate = candidates[i];
        if (!candidate) continue;
        const abs = srcWithAbsUrl(candidate);
        if (skipHeic && HEIC_RE.test(abs)) continue;
        const ok = await probeCandidate(candidate);
        if (!ok) continue;
        setCandidate(img, i, candidate);
        return true;
      }
      return false;
    };

    const initFallbacks = () => {
      const images = document.querySelectorAll("img[data-candidates]");
      images.forEach((img) => {
        if (!(img instanceof HTMLImageElement)) return;
        const { index } = parseCandidates(img);
        img.dataset.candidateIndex = String(index);
      });
    };

    const blobIsRenderable = async (blob: Blob): Promise<boolean> => {
      if (!(blob instanceof Blob) || blob.size <= 0) return false;
      let bitmap = null;
      if ("createImageBitmap" in window) {
        try {
          bitmap = await createImageBitmap(blob);
        } catch (_error) {
          bitmap = null;
        }
      }

      if (bitmap && bitmap.width > 1 && bitmap.height > 1) {
        try {
          const sampleW = Math.max(1, Math.min(64, bitmap.width));
          const sampleH = Math.max(1, Math.min(64, bitmap.height));
          const canvas = document.createElement("canvas");
          canvas.width = sampleW;
          canvas.height = sampleH;
          const ctx = canvas.getContext("2d", { willReadFrequently: true });
          if (ctx) {
            ctx.drawImage(bitmap, 0, 0, sampleW, sampleH);
            const data = ctx.getImageData(0, 0, sampleW, sampleH).data;
            const pxCount = sampleW * sampleH;
            let alphaSum = 0;
            let lumSum = 0;
            let lumSqSum = 0;
            for (let i = 0; i < data.length; i += 4) {
              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];
              const a = data[i + 3];
              alphaSum += a;
              const lum = 0.2126 * r + 0.7152 * g + 0.0722 * b;
              lumSum += lum;
              lumSqSum += lum * lum;
            }
            const alphaAvg = alphaSum / pxCount;
            const lumAvg = lumSum / pxCount;
            const lumVar = lumSqSum / pxCount - lumAvg * lumAvg;
            // Reject transparent/flat-black decodes that appear "successful" but render as empty cards.
            if (alphaAvg > 5 && !(lumAvg < 2 && lumVar < 1)) {
              bitmap.close();
              return true;
            }
          }
        } catch (_error) {
          // fall through to Image decode check
        } finally {
          bitmap.close();
        }
      }

      const objectUrl = URL.createObjectURL(blob);
      try {
        const ok = await new Promise((resolve) => {
          const probe = new Image();
          probe.onload = () => resolve((probe.naturalWidth || 0) > 1 && (probe.naturalHeight || 0) > 1);
          probe.onerror = () => resolve(false);
          probe.src = objectUrl;
        });
        return Boolean(ok);
      } finally {
        URL.revokeObjectURL(objectUrl);
      }
    };

    const convertHeicToJpeg = async (img: HTMLImageElement, source: string): Promise<boolean> => {
      const heicSrc = srcWithAbsUrl(source);
      if (!HEIC_RE.test(heicSrc)) return false;
      const cached = convertedImageUrlCache.get(heicSrc);
      if (cached) {
        img.src = cached;
        return true;
      }
      const known = heicConvertResultCache.get(heicSrc);
      if (known === false) return false;

      const res = await fetch(heicSrc, { credentials: "same-origin" });
      if (!res.ok) {
        heicConvertResultCache.set(heicSrc, false);
        return false;
      }
      const raw = await res.arrayBuffer();
      const sourceBytes = raw.byteLength;
      const typedBlob = new Blob([raw], {
        type: /\.heif(?:[?#].*)?$/i.test(heicSrc) ? "image/heif" : "image/heic",
      });
      const conversionTargets = [
        { toType: "image/jpeg", quality: 0.9 },
        { toType: "image/png", quality: 1 },
      ];
      const heic2any = await loadHeic2any();
      for (const target of conversionTargets) {
        const converted = await heic2any({
          blob: typedBlob,
          toType: target.toType,
          quality: target.quality,
        });
        const outBlob = Array.isArray(converted) ? converted[0] : converted;
        if (!(outBlob instanceof Blob)) continue;

        // Broken HEIC decodes sometimes yield tiny unusable blobs.
        if (sourceBytes > 256 * 1024 && outBlob.size < 8 * 1024) continue;
        const renderable = await blobIsRenderable(outBlob);
        if (!renderable) continue;

        const objectUrl = URL.createObjectURL(outBlob);
        convertedImageUrlCache.set(heicSrc, objectUrl);
        heicConvertResultCache.set(heicSrc, true);
        img.src = objectUrl;
        return true;
      }
      heicConvertResultCache.set(heicSrc, false);
      return false;
    };

    const recoverImage = async (
      img: HTMLImageElement,
      { fromError }: { fromError: boolean }
    ) => {
      if (img.dataset.recovering === "1") return;
      img.dataset.recovering = "1";
      try {
        const { candidates, index } = parseCandidates(img);
        if (!candidates.length) {
          img.src = "/collage/moodboard.jpg";
          return;
        }

        const startIndex = fromError ? Math.min(index + 1, candidates.length - 1) : index;
        const skipHeic = !isProbablySafari();
        const foundStatic = await findWorkingCandidate(img, startIndex, { skipHeic });
        if (foundStatic) return;

        if (!skipHeic) {
          const foundHeic = await findWorkingCandidate(img, startIndex, { skipHeic: false });
          if (foundHeic) return;
        }

        for (const candidate of candidates) {
          if (!candidate) continue;
          if (!HEIC_RE.test(srcWithAbsUrl(candidate))) continue;
          try {
            const converted = await convertHeicToJpeg(img, candidate);
            if (converted) return;
          } catch (_error) {
            // continue through next HEIC candidate
          }
        }

        img.src = "/collage/moodboard.jpg";
      } finally {
        img.dataset.recovering = "0";
      }
    };

    const primeBrokenWallImages = async () => {
      const images = document.querySelectorAll("img[data-candidates]");
      for (const img of images) {
        if (!(img instanceof HTMLImageElement)) continue;
        if (!img.complete) continue;
        if ((img.naturalWidth || 0) > 1 && (img.naturalHeight || 0) > 1) continue;
        await recoverImage(img, { fromError: false });
      }
    };

    if (!(window as any).__twawFrameWallFallbackBound) {
      document.addEventListener(
        "error",
        (event) => {
          const target = event.target;
          if (!(target instanceof HTMLImageElement)) return;
          if (!target.dataset.candidates) return;
          void recoverImage(target, { fromError: true });
        },
        true,
      );
      (window as any).__twawFrameWallFallbackBound = true;
    }

    document.addEventListener(
      "load",
      (event) => {
        if (!(event.target instanceof HTMLImageElement)) return;
        resolvePairLayouts();
      },
      true,
    );

    const bindLightboxSwipe = () => {
      if ((window as any).__twawFrameWallSwipeBound) return;

      const swipeState = {
        activeFrame: null as HTMLElement | null,
        startX: 0,
        startY: 0,
        touchId: null as number | null,
      };
      const SWIPE_THRESHOLD_X = 44;
      const SWIPE_DOMINANCE_RATIO = 1.2;

      const getActiveLightbox = () => document.querySelector<HTMLElement>(".lb:target");

      const navigateTo = (index: string | null | undefined) => {
        const normalized = typeof index === "string" ? index.trim() : "";
        if (!normalized) return;
        window.location.hash = `lb-${normalized}`;
      };

      const findTouchById = (touches: TouchList, id: number | null) => {
        if (id == null) return null;
        for (let i = 0; i < touches.length; i += 1) {
          const touch = touches.item(i);
          if (touch?.identifier === id) return touch;
        }
        return null;
      };

      const startSwipe = (frame: HTMLElement, x: number, y: number, touchId: number | null = null) => {
        swipeState.activeFrame = frame;
        swipeState.startX = x;
        swipeState.startY = y;
        swipeState.touchId = touchId;
      };

      const endSwipe = (x: number, y: number) => {
        const frame = swipeState.activeFrame;
        if (!frame) return;
        const lightbox = frame.closest<HTMLElement>(".lb");
        if (!lightbox) return;

        const dx = x - swipeState.startX;
        const dy = y - swipeState.startY;
        const absDx = Math.abs(dx);
        const absDy = Math.abs(dy);
        const dominantX = absDx >= absDy * SWIPE_DOMINANCE_RATIO;
        if (!dominantX || absDx < SWIPE_THRESHOLD_X) return;

        if (dx < 0) {
          navigateTo(lightbox.dataset.lbNext);
          return;
        }
        navigateTo(lightbox.dataset.lbPrev);
      };

      document.addEventListener(
        "pointerdown",
        (event) => {
          if (event.pointerType === "mouse") return;
          const frame = (event.target as Element | null)?.closest?.(".lb:target .lb-frame");
          if (!(frame instanceof HTMLElement)) return;
          startSwipe(frame, event.clientX, event.clientY);
        },
        { passive: true },
      );

      document.addEventListener(
        "pointerup",
        (event) => {
          if (event.pointerType === "mouse") return;
          if (!swipeState.activeFrame) return;
          endSwipe(event.clientX, event.clientY);
          swipeState.activeFrame = null;
          swipeState.touchId = null;
        },
        { passive: true },
      );

      document.addEventListener(
        "pointercancel",
        () => {
          swipeState.activeFrame = null;
          swipeState.touchId = null;
        },
        { passive: true },
      );

      document.addEventListener(
        "touchstart",
        (event) => {
          const target = event.target as Element | null;
          const frame = target?.closest?.(".lb:target .lb-frame");
          if (!(frame instanceof HTMLElement)) return;
          if (event.changedTouches.length < 1) return;
          const touch = event.changedTouches.item(0);
          if (!touch) return;
          startSwipe(frame, touch.clientX, touch.clientY, touch.identifier);
        },
        { passive: true },
      );

      document.addEventListener(
        "touchend",
        (event) => {
          if (!swipeState.activeFrame) return;
          const touch = findTouchById(event.changedTouches, swipeState.touchId);
          if (!touch) return;
          endSwipe(touch.clientX, touch.clientY);
          swipeState.activeFrame = null;
          swipeState.touchId = null;
        },
        { passive: true },
      );

      document.addEventListener(
        "touchcancel",
        () => {
          swipeState.activeFrame = null;
          swipeState.touchId = null;
        },
        { passive: true },
      );

      document.addEventListener("keydown", (event) => {
        const active = getActiveLightbox();
        if (!active) return;
        if (event.key === "ArrowRight") {
          event.preventDefault();
          navigateTo(active.dataset.lbNext);
          return;
        }
        if (event.key === "ArrowLeft") {
          event.preventDefault();
          navigateTo(active.dataset.lbPrev);
          return;
        }
        if (event.key === "Escape") {
          event.preventDefault();
          window.location.hash = "lb-close";
        }
      });

      (window as any).__twawFrameWallSwipeBound = true;
    };

    initFallbacks();
    resolvePairLayouts();
    bindLightboxSwipe();
    window.setTimeout(() => {
      void primeBrokenWallImages();
    }, 300);
    window.setTimeout(() => {
      void primeBrokenWallImages();
    }, 1600);
    window.setTimeout(() => {
      void primeBrokenWallImages();
    }, 3600);
    document.addEventListener("astro:page-load", () => {
      initFallbacks();
      resolvePairLayouts();
      bindLightboxSwipe();
      window.setTimeout(() => {
        void primeBrokenWallImages();
      }, 300);
      window.setTimeout(() => {
        void primeBrokenWallImages();
      }, 1600);
      window.setTimeout(() => {
        void primeBrokenWallImages();
      }, 3600);
    });
  </script>
</div>
