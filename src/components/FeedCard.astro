---
import { formatDate } from "../lib/formatDate";
import { topicMeta } from "../config/topics";

type Props = {
  href: string;
  title: string;
  description?: string;
  author?: string;
  image: string;
  date?: Date | string;
  topic?: string;
  locked?: boolean;
  pinned?: boolean;
  pinnedStyle?: string;
  searchText?: string;
  dateKey?: string;
  anchorId?: string;
};

const {
  href,
  title,
  description = "",
  author = "",
  image,
  date,
  topic,
  locked = false,
  pinned = false,
  pinnedStyle,
  searchText,
  dateKey,
  anchorId,
} = Astro.props as Props;

const meta = topicMeta(topic);
const showPinBadge = pinned && import.meta.env.PUBLIC_ENABLE_PINNED_BADGE !== "false";
const pinLabelMap: Record<string, string> = {
  event: "S·ª± ki·ªán",
  announcement: "Th√¥ng b√°o",
  memory: "K·ª∑ ni·ªám",
};
const pinLabel = pinnedStyle && pinLabelMap[pinnedStyle] ? pinLabelMap[pinnedStyle] : "Ghim";

const buildImageCandidates = (src: string) => {
  const [pathPart, suffix = ""] = src.split(/([?#].*)/, 2);
  const ext = pathPart.split(".").pop() ?? "";
  if (!ext) return [src, "/noise.svg"];

  const lower = ext.toLowerCase();
  const base = pathPart.slice(0, -ext.length);
  const suffixPart = suffix || "";
  const candidates = [src];

  const add = (nextPath: string) => {
    const next = `${nextPath}${suffixPart}`;
    if (!candidates.includes(next)) candidates.push(next);
  };

  if (ext !== lower) add(`${base}${lower}`);
  const upper = ext.toUpperCase();
  if (ext !== upper) add(`${base}${upper}`);

  if (lower === "heic" || lower === "heif") {
    add(`${base}jpg`);
    add(`${base}jpeg`);
    add(`${base}png`);
    add(`${base}webp`);

    const coverDir = pathPart.match(/^(.*\/)cover\.[^.]+$/i)?.[1];
    if (coverDir) {
      add(`${coverDir}01.jpg`);
      add(`${coverDir}01.jpeg`);
      add(`${coverDir}01.png`);
      add(`${coverDir}01.webp`);
      add(`${coverDir}1.jpg`);
      add(`${coverDir}1.jpeg`);
      add(`${coverDir}1.png`);
      add(`${coverDir}1.webp`);
    }
  }

  add("/noise.svg");
  return candidates;
};

const imageCandidates = buildImageCandidates(image);
---

<a
  href={href}
  class={`feed-card ${locked ? "is-locked" : ""} ${pinned ? "is-pinned" : ""}`}
  data-search={searchText?.toLowerCase()}
  data-date={dateKey}
  id={anchorId}
>
  <div class="feed-card__head">
    <div class="feed-card__topic" style={`--topic-color:${meta.color};`}>
      <span class="feed-card__icon">{meta.icon}</span>
      <span>{meta.label}</span>
    </div>
    {date && <div class="feed-card__date">{formatDate(date)}</div>}
  </div>
  {showPinBadge && (
    <span class="feed-card__pin" data-pin-style={pinnedStyle ?? "default"} aria-label="B√†i ghim">
      üìå {pinLabel}
    </span>
  )}

  <h3 class="feed-card__title">{title}</h3>
  {!locked && (description || author) && (
    <div class="feed-card__meta-line">
      {description && <p class="feed-card__desc">{description}</p>}
      {author && <span class="feed-card__author">‚Äî {author}</span>}
    </div>
  )}
  {locked && <p class="feed-card__desc">üîí ƒê√£ kh√≥a</p>}

  <div class="feed-card__media">
    <img
      src={image}
      alt=""
      loading="lazy"
      decoding="async"
      data-candidates={imageCandidates.join("|")}
      data-candidate-index="0"
    />
  </div>
</a>

<script>
  import heic2any from "heic2any";

  const HEIC_RE = /\.(heic|heif)(?:[?#].*)?$/i;
  const convertedImageUrlCache = new Map();

  const initFeedImageFallbacks = () => {
    const imgs = document.querySelectorAll(".feed-card__media img[data-candidates]");
    imgs.forEach((img) => {
      if (!(img instanceof HTMLImageElement)) return;
      if (!img.dataset.candidateIndex) img.dataset.candidateIndex = "0";
    });
  };

  const srcWithAbsUrl = (value) => {
    try {
      return new URL(value, window.location.origin).toString();
    } catch (_error) {
      return value;
    }
  };

  const nextCandidate = (img) => {
    const raw = img.dataset.candidates;
    if (!raw) return null;
    const candidates = raw.split("|").filter(Boolean);
    const nextIndex = Number(img.dataset.candidateIndex ?? "0") + 1;
    if (nextIndex >= candidates.length) return null;
    img.dataset.candidateIndex = String(nextIndex);
    return candidates[nextIndex];
  };

  const blobIsRenderable = async (blob) => {
    if (!(blob instanceof Blob) || blob.size <= 0) return false;
    let bitmap = null;
    if ("createImageBitmap" in window) {
      try {
        bitmap = await createImageBitmap(blob);
      } catch (_error) {
        bitmap = null;
      }
    }

    if (bitmap && bitmap.width > 1 && bitmap.height > 1) {
      try {
        const sampleW = Math.max(1, Math.min(64, bitmap.width));
        const sampleH = Math.max(1, Math.min(64, bitmap.height));
        const canvas = document.createElement("canvas");
        canvas.width = sampleW;
        canvas.height = sampleH;
        const ctx = canvas.getContext("2d", { willReadFrequently: true });
        if (ctx) {
          ctx.drawImage(bitmap, 0, 0, sampleW, sampleH);
          const data = ctx.getImageData(0, 0, sampleW, sampleH).data;
          const pxCount = sampleW * sampleH;
          let alphaSum = 0;
          let lumSum = 0;
          let lumSqSum = 0;
          for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            const a = data[i + 3];
            alphaSum += a;
            const lum = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            lumSum += lum;
            lumSqSum += lum * lum;
          }
          const alphaAvg = alphaSum / pxCount;
          const lumAvg = lumSum / pxCount;
          const lumVar = lumSqSum / pxCount - lumAvg * lumAvg;
          // Reject transparent/flat-black decodes that appear "successful" but render as empty cards.
          if (alphaAvg > 5 && !(lumAvg < 2 && lumVar < 1)) {
            bitmap.close();
            return true;
          }
        }
      } catch (_error) {
        // fall through to Image decode check
      } finally {
        bitmap.close();
      }
    }

    const objectUrl = URL.createObjectURL(blob);
    try {
      const ok = await new Promise((resolve) => {
        const probe = new Image();
        probe.onload = () => resolve((probe.naturalWidth || 0) > 1 && (probe.naturalHeight || 0) > 1);
        probe.onerror = () => resolve(false);
        probe.src = objectUrl;
      });
      return Boolean(ok);
    } finally {
      URL.revokeObjectURL(objectUrl);
    }
  };

  const convertHeicToJpeg = async (img) => {
    const currentSrc = srcWithAbsUrl(img.currentSrc || img.src || "");
    if (!HEIC_RE.test(currentSrc)) return false;
    if (img.dataset.heicConverted === "1") return false;
    img.dataset.heicConverted = "1";

    const cached = convertedImageUrlCache.get(currentSrc);
    if (cached) {
      img.src = cached;
      return true;
    }

    const res = await fetch(currentSrc, { credentials: "same-origin" });
    if (!res.ok) return false;
    const raw = await res.arrayBuffer();
    const sourceBytes = raw.byteLength;
    const typedBlob = new Blob([raw], {
      type: /\.heif(?:[?#].*)?$/i.test(currentSrc) ? "image/heif" : "image/heic",
    });

    const conversionTargets = [
      { toType: "image/jpeg", quality: 0.9 },
      { toType: "image/png", quality: 1 },
    ];
    for (const target of conversionTargets) {
      const converted = await heic2any({
        blob: typedBlob,
        toType: target.toType,
        quality: target.quality,
      });
      const outBlob = Array.isArray(converted) ? converted[0] : converted;
      if (!(outBlob instanceof Blob)) continue;

      // Broken HEIC decodes sometimes yield tiny unusable blobs.
      if (sourceBytes > 256 * 1024 && outBlob.size < 8 * 1024) continue;
      const renderable = await blobIsRenderable(outBlob);
      if (!renderable) continue;

      const objectUrl = URL.createObjectURL(outBlob);
      convertedImageUrlCache.set(currentSrc, objectUrl);
      img.src = objectUrl;
      return true;
    }
    return false;
  };

  if (!window.__twawFeedImageFallbackBound) {
    document.addEventListener(
      "error",
      (event) => {
        const target = event.target;
        if (!(target instanceof HTMLImageElement)) return;
        if (!target.matches(".feed-card__media img[data-candidates]")) return;

        const tryFallback = async () => {
          try {
            const converted = await convertHeicToJpeg(target);
            if (converted) return;
          } catch (_error) {
            // fallback to path candidates below
          }

          const next = nextCandidate(target);
          if (next) {
            target.src = next;
            return;
          }
          target.src = "/noise.svg";
        };

        void tryFallback();
      },
      true,
    );
    window.__twawFeedImageFallbackBound = true;
  }

  initFeedImageFallbacks();
  document.addEventListener("astro:page-load", initFeedImageFallbacks);
</script>
