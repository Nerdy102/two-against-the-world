---
import { formatDate } from "../lib/formatDate";
import { topicMeta } from "../config/topics";
import { splitSummaryFollowUp } from "../lib/followUpLink";

type Props = {
  href: string;
  title: string;
  description?: string;
  author?: string;
  image: string;
  date?: Date | string;
  topic?: string;
  locked?: boolean;
  pinned?: boolean;
  pinnedStyle?: string;
  searchText?: string;
  dateKey?: string;
  anchorId?: string;
  timeZone?: string;
};

const {
  href,
  title,
  description = "",
  author = "",
  image,
  date,
  topic,
  locked = false,
  pinned = false,
  pinnedStyle,
  searchText,
  dateKey,
  anchorId,
  timeZone,
} = Astro.props as Props;

const meta = topicMeta(topic);
const { summaryText } = splitSummaryFollowUp(description);
const showPinBadge = pinned && import.meta.env.PUBLIC_ENABLE_PINNED_BADGE !== "false";
const pinLabelMap: Record<string, string> = {
  event: "S·ª± ki·ªán",
  announcement: "Th√¥ng b√°o",
  memory: "K·ª∑ ni·ªám",
};
const pinLabel = pinnedStyle && pinLabelMap[pinnedStyle] ? pinLabelMap[pinnedStyle] : "Ghim";

const FALLBACK_POOL = [
  "/collage/moodboard.jpg",
  "/collage/dinner.jpg",
  "/collage/taste-angel-03.jpg",
  "/collage/scrapbook-love.jpg",
];

const pickFallbackImage = (seed: string) => {
  let hash = 0;
  for (let i = 0; i < seed.length; i += 1) {
    hash = (hash * 33 + seed.charCodeAt(i)) >>> 0;
  }
  return FALLBACK_POOL[hash % FALLBACK_POOL.length]!;
};

const fallbackImage = pickFallbackImage(`${href}|${title}|${topic ?? ""}`);
const enableCfImageResize =
  !import.meta.env.DEV && import.meta.env.PUBLIC_ENABLE_CF_IMAGE_OPTIMIZE === "true";

const CDN_IMAGE_EXTENSIONS = new Set([
  "jpg",
  "jpeg",
  "png",
  "webp",
  "avif",
  "heic",
  "heif",
]);

const toCloudflareResizedCandidate = (pathPart: string, suffix: string): string | null => {
  if (!enableCfImageResize) return null;
  if (!pathPart.startsWith("/")) return null;
  if (pathPart.startsWith("/cdn-cgi/image/")) return null;
  const ext = pathPart.split(".").pop()?.toLowerCase() ?? "";
  if (!CDN_IMAGE_EXTENSIONS.has(ext)) return null;
  const encodedPath = encodeURI(pathPart.replace(/^\/+/, ""));
  return `/cdn-cgi/image/format=auto,fit=cover,width=960,quality=76/${encodedPath}${suffix}`;
};

const buildImageCandidates = (src: string, defaultFallback: string) => {
  const [pathPart, suffix = ""] = src.split(/([?#].*)/, 2);
  const ext = pathPart.split(".").pop() ?? "";
  if (!ext) return [src, defaultFallback];

  const lower = ext.toLowerCase();
  const base = pathPart.slice(0, -ext.length);
  const suffixPart = suffix || "";
  const candidates: string[] = [];

  const add = (nextPath: string) => {
    const resized = toCloudflareResizedCandidate(nextPath, suffixPart);
    if (resized && !candidates.includes(resized)) candidates.push(resized);
    const next = `${nextPath}${suffixPart}`;
    if (!candidates.includes(next)) candidates.push(next);
  };

  add(pathPart);

  if (ext !== lower) add(`${base}${lower}`);
  const upper = ext.toUpperCase();
  if (ext !== upper) add(`${base}${upper}`);

  const mediaProxyMatch = pathPart.match(/^https?:\/\/[^/]+\/media\/(.+)$/i);
  if (mediaProxyMatch?.[1]) {
    const localMediaPath = `/media/${mediaProxyMatch[1]}`;
    add(localMediaPath);
    const localExt = localMediaPath.split(".").pop() ?? "";
    if (localExt) {
      const localBase = localMediaPath.slice(0, -localExt.length);
      const localLower = localExt.toLowerCase();
      if (localExt !== localLower) add(`${localBase}${localLower}`);
      const localUpper = localExt.toUpperCase();
      if (localExt !== localUpper) add(`${localBase}${localUpper}`);
    }
  }

  if (lower === "heic" || lower === "heif") {
    add(`${base}jpg`);
    add(`${base}jpeg`);
    add(`${base}png`);
    add(`${base}webp`);

    const coverDir = pathPart.match(/^(.*\/)cover\.[^.]+$/i)?.[1];
    if (coverDir) {
      add(`${coverDir}01.jpg`);
      add(`${coverDir}01.jpeg`);
      add(`${coverDir}01.png`);
      add(`${coverDir}01.webp`);
      add(`${coverDir}1.jpg`);
      add(`${coverDir}1.jpeg`);
      add(`${coverDir}1.png`);
      add(`${coverDir}1.webp`);
    }
  }

  add(defaultFallback);
  return candidates;
};

const imageCandidates = buildImageCandidates(image, fallbackImage);
const initialImage = imageCandidates[0] ?? image;
---

<a
  href={href}
  class={`feed-card ${locked ? "is-locked" : ""} ${pinned ? "is-pinned" : ""}`}
  data-search={searchText?.toLowerCase()}
  data-date={dateKey}
  id={anchorId}
>
  <div class="feed-card__head">
    <div class="feed-card__topic" style={`--topic-color:${meta.color};`}>
      <span class="feed-card__icon">{meta.icon}</span>
      <span>{meta.label}</span>
    </div>
    {date && <div class="feed-card__date">{formatDate(date, { includeTime: true, timeZone })}</div>}
  </div>
  {showPinBadge && (
    <span class="feed-card__pin" data-pin-style={pinnedStyle ?? "default"} aria-label="B√†i ghim">
      üìå {pinLabel}
    </span>
  )}

  <h3 class="feed-card__title">{title}</h3>
  {!locked && (summaryText || author) && (
    <div class="feed-card__meta-line">
      {summaryText && <p class="feed-card__desc">{summaryText}</p>}
      {author && <span class="feed-card__author">‚Äî {author}</span>}
    </div>
  )}
  {locked && <p class="feed-card__desc">üîí ƒê√£ kh√≥a</p>}

  <div class="feed-card__media">
    <img
      src={initialImage}
      alt=""
      loading="lazy"
      decoding="async"
      data-candidates={imageCandidates.join("|")}
      data-candidate-index="0"
      data-fallback={fallbackImage}
    />
  </div>
</a>

<script>
  const HEIC_RE = /\.(heic|heif)(?:[?#].*)?$/i;
  const convertedImageUrlCache = new Map();
  let heic2anyLoader: Promise<any> | null = null;
  const NON_SAFARI_RE = /(chrome|crios|edg|opr|android)/i;

  const loadHeic2any = async () => {
    if (!heic2anyLoader) {
      heic2anyLoader = import("heic2any").then((mod) => mod.default ?? mod);
    }
    return heic2anyLoader;
  };

  const initFeedImageFallbacks = () => {
    const imgs = document.querySelectorAll(".feed-card__media img[data-candidates]");
    imgs.forEach((img) => {
      if (!(img instanceof HTMLImageElement)) return;
      if (!img.dataset.candidateIndex) img.dataset.candidateIndex = "0";
    });
  };

  const srcWithAbsUrl = (value: string): string => {
    try {
      return new URL(value, window.location.origin).toString();
    } catch (_error) {
      return value;
    }
  };

  const nextCandidate = (img: HTMLImageElement): string | null => {
    const raw = img.dataset.candidates;
    if (!raw) return null;
    const candidates = raw.split("|").filter(Boolean);
    const nextIndex = Number(img.dataset.candidateIndex ?? "0") + 1;
    if (nextIndex >= candidates.length) return null;
    img.dataset.candidateIndex = String(nextIndex);
    return candidates[nextIndex];
  };

  const blobIsRenderable = async (blob: Blob): Promise<boolean> => {
    if (!(blob instanceof Blob) || blob.size <= 0) return false;
    let bitmap = null;
    if ("createImageBitmap" in window) {
      try {
        bitmap = await createImageBitmap(blob);
      } catch (_error) {
        bitmap = null;
      }
    }

    if (bitmap && bitmap.width > 1 && bitmap.height > 1) {
      try {
        const sampleW = Math.max(1, Math.min(64, bitmap.width));
        const sampleH = Math.max(1, Math.min(64, bitmap.height));
        const canvas = document.createElement("canvas");
        canvas.width = sampleW;
        canvas.height = sampleH;
        const ctx = canvas.getContext("2d", { willReadFrequently: true });
        if (ctx) {
          ctx.drawImage(bitmap, 0, 0, sampleW, sampleH);
          const data = ctx.getImageData(0, 0, sampleW, sampleH).data;
          const pxCount = sampleW * sampleH;
          let alphaSum = 0;
          let lumSum = 0;
          let lumSqSum = 0;
          for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            const a = data[i + 3];
            alphaSum += a;
            const lum = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            lumSum += lum;
            lumSqSum += lum * lum;
          }
          const alphaAvg = alphaSum / pxCount;
          const lumAvg = lumSum / pxCount;
          const lumVar = lumSqSum / pxCount - lumAvg * lumAvg;
          // Reject transparent/flat-black decodes that appear "successful" but render as empty cards.
          if (alphaAvg > 5 && !(lumAvg < 2 && lumVar < 1)) {
            bitmap.close();
            return true;
          }
        }
      } catch (_error) {
        // fall through to Image decode check
      } finally {
        bitmap.close();
      }
    }

    const objectUrl = URL.createObjectURL(blob);
    try {
      const ok = await new Promise((resolve) => {
        const probe = new Image();
        probe.onload = () => resolve((probe.naturalWidth || 0) > 1 && (probe.naturalHeight || 0) > 1);
        probe.onerror = () => resolve(false);
        probe.src = objectUrl;
      });
      return Boolean(ok);
    } finally {
      URL.revokeObjectURL(objectUrl);
    }
  };

  const convertHeicToJpeg = async (img: HTMLImageElement): Promise<boolean> => {
    const currentSrc = srcWithAbsUrl(img.currentSrc || img.src || "");
    if (!HEIC_RE.test(currentSrc)) return false;
    if (img.dataset.heicConverted === "1") return false;
    img.dataset.heicConverted = "1";

    const cached = convertedImageUrlCache.get(currentSrc);
    if (cached) {
      img.src = cached;
      return true;
    }

    const res = await fetch(currentSrc, { credentials: "same-origin" });
    if (!res.ok) return false;
    const raw = await res.arrayBuffer();
    const sourceBytes = raw.byteLength;
    const typedBlob = new Blob([raw], {
      type: /\.heif(?:[?#].*)?$/i.test(currentSrc) ? "image/heif" : "image/heic",
    });

    const conversionTargets = [
      { toType: "image/jpeg", quality: 0.9 },
      { toType: "image/png", quality: 1 },
    ];
    const heic2any = await loadHeic2any();
    for (const target of conversionTargets) {
      const converted = await heic2any({
        blob: typedBlob,
        toType: target.toType,
        quality: target.quality,
      });
      const outBlob = Array.isArray(converted) ? converted[0] : converted;
      if (!(outBlob instanceof Blob)) continue;

      // Broken HEIC decodes sometimes yield tiny unusable blobs.
      if (sourceBytes > 256 * 1024 && outBlob.size < 8 * 1024) continue;
      const renderable = await blobIsRenderable(outBlob);
      if (!renderable) continue;

      const objectUrl = URL.createObjectURL(outBlob);
      convertedImageUrlCache.set(currentSrc, objectUrl);
      img.src = objectUrl;
      return true;
    }
    return false;
  };

  const isProbablySafari = () =>
    /safari/i.test(navigator.userAgent) && !NON_SAFARI_RE.test(navigator.userAgent);

  const primeHeicFallbacks = async () => {
    if (isProbablySafari()) return;
    const imgs = document.querySelectorAll(".feed-card__media img[data-candidates]");
    for (const img of imgs) {
      if (!(img instanceof HTMLImageElement)) continue;
      if (img.dataset.heicPrimed === "1") continue;
      const currentSrc = srcWithAbsUrl(img.currentSrc || img.src || "");
      if (!HEIC_RE.test(currentSrc)) continue;
      img.dataset.heicPrimed = "1";

      // If browser already decoded it fine, do nothing.
      if (img.complete && (img.naturalWidth || 0) > 1 && (img.naturalHeight || 0) > 1) continue;

      try {
        const converted = await convertHeicToJpeg(img);
        if (converted) continue;
      } catch (_error) {
        // fallback path below
      }
      const next = nextCandidate(img);
      if (next) img.src = next;
    }
  };

  if (!(window as any).__twawFeedImageFallbackBound) {
    document.addEventListener(
      "error",
      (event) => {
        const target = event.target;
        if (!(target instanceof HTMLImageElement)) return;
        if (!target.matches(".feed-card__media img[data-candidates]")) return;

        const tryFallback = async () => {
          try {
            const converted = await convertHeicToJpeg(target);
            if (converted) return;
          } catch (_error) {
            // fallback to path candidates below
          }

          const next = nextCandidate(target);
          if (next) {
            target.src = next;
            return;
          }
          target.src = target.dataset.fallback || "/collage/moodboard.jpg";
        };

        void tryFallback();
      },
      true,
    );
    (window as any).__twawFeedImageFallbackBound = true;
  }

  initFeedImageFallbacks();
  void primeHeicFallbacks();
  document.addEventListener("astro:page-load", initFeedImageFallbacks);
  document.addEventListener("astro:page-load", () => {
    void primeHeicFallbacks();
  });
</script>
