---
import { formatDate } from "../lib/formatDate";
import { topicMeta } from "../config/topics";
import { splitSummaryFollowUp } from "../lib/followUpLink";

type Props = {
  href: string;
  title: string;
  description?: string;
  author?: string;
  image: string;
  date?: Date | string;
  topic?: string;
  locked?: boolean;
  pinned?: boolean;
  pinnedStyle?: string;
  searchText?: string;
  dateKey?: string;
  anchorId?: string;
  timeZone?: string;
};

const {
  href,
  title,
  description = "",
  author = "",
  image,
  date,
  topic,
  locked = false,
  pinned = false,
  pinnedStyle,
  searchText,
  dateKey,
  anchorId,
  timeZone,
} = Astro.props as Props;

const meta = topicMeta(topic);
const { summaryText, followUpUrl, followUpLabel } = splitSummaryFollowUp(description);
const showPinBadge = pinned && import.meta.env.PUBLIC_ENABLE_PINNED_BADGE !== "false";
const pinLabelMap: Record<string, string> = {
  event: "S·ª± ki·ªán",
  announcement: "Th√¥ng b√°o",
  memory: "K·ª∑ ni·ªám",
};
const pinLabel = pinnedStyle && pinLabelMap[pinnedStyle] ? pinLabelMap[pinnedStyle] : "Ghim";

const zoneOptions = [
  { timeZone: "Asia/Ho_Chi_Minh", label: "üáªüá≥ Gi·ªù Vi·ªát" },
  { timeZone: "Asia/Tokyo", label: "üáØüáµ Gi·ªù Nh·∫≠t" },
  { timeZone: "America/New_York", label: "üá∫üá∏ Gi·ªù M·ªπ" },
] as const;

const hashSeed = (seed: string) => {
  let hash = 0;
  for (let i = 0; i < seed.length; i += 1) {
    hash = (hash * 33 + seed.charCodeAt(i)) >>> 0;
  }
  return hash;
};

const resolveZone = (value?: string) => {
  const tz = typeof value === "string" ? value.trim() : "";
  if (tz === "Asia/Ho_Chi_Minh" || tz === "Asia/Saigon") return zoneOptions[0];
  if (tz === "Asia/Tokyo") return zoneOptions[1];
  if (tz.startsWith("America/") || tz === "Pacific/Honolulu") return zoneOptions[2];
  const fallbackIndex = hashSeed(`${href}|${title}|${String(date ?? "")}`) % zoneOptions.length;
  return zoneOptions[fallbackIndex]!;
};

const formatTimeInZone = (input: Date | string, timeZoneValue: string) => {
  const parsed = input instanceof Date ? input : new Date(input);
  if (Number.isNaN(parsed.getTime())) return "";
  return new Intl.DateTimeFormat("en-GB", {
    hour: "2-digit",
    minute: "2-digit",
    hour12: false,
    hourCycle: "h23",
    timeZone: timeZoneValue,
  }).format(parsed);
};

const isUnknownMidnight = (input: Date | string, timeZoneValue: string) => {
  if (typeof input === "string") {
    const raw = input.trim();
    if (/^\d{4}-\d{2}-\d{2}$/.test(raw)) return true;
    if (/[T ]00:00(?::00(?:\.\d+)?)?(?:Z|[+-]\d{2}:\d{2})?$/.test(raw)) return true;
  }
  return formatTimeInZone(input, timeZoneValue) === "00:00";
};

const buildSyntheticTime = (seed: string) => {
  const minuteOfDay = 7 * 60 + (hashSeed(seed) % (15 * 60));
  const hh = String(Math.floor(minuteOfDay / 60)).padStart(2, "0");
  const mm = String(minuteOfDay % 60).padStart(2, "0");
  return `${hh}:${mm}`;
};

const resolvedZone = resolveZone(timeZone);
const dateText = date
  ? (() => {
      const datePart = formatDate(date, { locale: "en-US", timeZone: resolvedZone.timeZone });
      const timePart = isUnknownMidnight(date, resolvedZone.timeZone)
        ? buildSyntheticTime(`${href}|${title}|${String(date)}`)
        : formatTimeInZone(date, resolvedZone.timeZone);
      return `${datePart}, ${timePart}`;
    })()
  : "";
const zoneLabel = resolvedZone.label;

const FALLBACK_POOL = [
  "/collage/moodboard.jpg",
  "/collage/dinner.jpg",
  "/collage/taste-angel-03.jpg",
  "/collage/scrapbook-love.jpg",
];

const pickFallbackImage = (seed: string) => {
  let hash = 0;
  for (let i = 0; i < seed.length; i += 1) {
    hash = (hash * 33 + seed.charCodeAt(i)) >>> 0;
  }
  return FALLBACK_POOL[hash % FALLBACK_POOL.length]!;
};

const fallbackImage = pickFallbackImage(`${href}|${title}|${topic ?? ""}`);
const enableCfImageResize =
  !import.meta.env.DEV && import.meta.env.PUBLIC_ENABLE_CF_IMAGE_OPTIMIZE === "true";

const CDN_IMAGE_EXTENSIONS = new Set([
  "jpg",
  "jpeg",
  "png",
  "webp",
  "avif",
  "heic",
  "heif",
]);

const toCloudflareResizedCandidate = (pathPart: string, suffix: string): string | null => {
  if (!enableCfImageResize) return null;
  if (!pathPart.startsWith("/")) return null;
  if (pathPart.startsWith("/cdn-cgi/image/")) return null;
  const ext = pathPart.split(".").pop()?.toLowerCase() ?? "";
  if (!CDN_IMAGE_EXTENSIONS.has(ext)) return null;
  const encodedPath = encodeURI(pathPart.replace(/^\/+/, ""));
  return `/cdn-cgi/image/format=auto,fit=cover,width=960,quality=76/${encodedPath}${suffix}`;
};

const buildImageCandidates = (src: string, defaultFallback: string) => {
  const [pathPart, suffix = ""] = src.split(/([?#].*)/, 2);
  const ext = pathPart.split(".").pop() ?? "";
  if (!ext) return [src, defaultFallback];

  const lower = ext.toLowerCase();
  const base = pathPart.slice(0, -ext.length);
  const suffixPart = suffix || "";
  const candidates: string[] = [];

  const add = (nextPath: string) => {
    const resized = toCloudflareResizedCandidate(nextPath, suffixPart);
    if (resized && !candidates.includes(resized)) candidates.push(resized);
    const next = `${nextPath}${suffixPart}`;
    if (!candidates.includes(next)) candidates.push(next);
  };

  const isHeicFamily = lower === "heic" || lower === "heif";

  // On non-Safari browsers, static JPG/PNG/WebP sidecars are far more reliable than direct HEIC.
  if (isHeicFamily) {
    add(`${base}jpg`);
    add(`${base}jpeg`);
    add(`${base}png`);
    add(`${base}webp`);
  }

  add(pathPart);

  if (ext !== lower) add(`${base}${lower}`);
  const upper = ext.toUpperCase();
  if (ext !== upper) add(`${base}${upper}`);

  const mediaProxyMatch = pathPart.match(/^https?:\/\/[^/]+\/media\/(.+)$/i);
  if (mediaProxyMatch?.[1]) {
    const localMediaPath = `/media/${mediaProxyMatch[1]}`;
    add(localMediaPath);
    const localExt = localMediaPath.split(".").pop() ?? "";
    if (localExt) {
      const localBase = localMediaPath.slice(0, -localExt.length);
      const localLower = localExt.toLowerCase();
      if (localExt !== localLower) add(`${localBase}${localLower}`);
      const localUpper = localExt.toUpperCase();
      if (localExt !== localUpper) add(`${localBase}${localUpper}`);
    }
  }

  if (isHeicFamily) {
    const coverDir = pathPart.match(/^(.*\/)cover\.[^.]+$/i)?.[1];
    if (coverDir) {
      add(`${coverDir}01.jpg`);
      add(`${coverDir}01.jpeg`);
      add(`${coverDir}01.png`);
      add(`${coverDir}01.webp`);
      add(`${coverDir}1.jpg`);
      add(`${coverDir}1.jpeg`);
      add(`${coverDir}1.png`);
      add(`${coverDir}1.webp`);
    }
  }

  add(defaultFallback);
  return candidates;
};

const imageCandidates = buildImageCandidates(image, fallbackImage);
const initialImage = imageCandidates[0] ?? image;
---

<a
  href={href}
  class={`feed-card ${locked ? "is-locked" : ""} ${pinned ? "is-pinned" : ""}`}
  data-search={searchText?.toLowerCase()}
  data-date={dateKey}
  id={anchorId}
>
  <div class="feed-card__head">
    <div class="feed-card__topic" style={`--topic-color:${meta.color};`}>
      <span class="feed-card__icon">{meta.icon}</span>
      <span>{meta.label}</span>
    </div>
    {date && (
      <div class="feed-card__date">
        <span class="feed-card__date-main">{dateText}</span>
        <span class="feed-card__date-zone">{zoneLabel}</span>
      </div>
    )}
  </div>
  {showPinBadge && (
    <span class="feed-card__pin" data-pin-style={pinnedStyle ?? "default"} aria-label="B√†i ghim">
      <span class="feed-card__pin-emoji" aria-hidden="true">üìå</span>
      <span class="feed-card__pin-label">{pinLabel}</span>
    </span>
  )}

  <h3 class="feed-card__title">{title}</h3>
  {!locked && (summaryText || followUpUrl || author) && (
    <div class="feed-card__meta-line">
      {summaryText && <p class="feed-card__desc">{summaryText}</p>}
      {followUpUrl && (
        <span class="feed-card__follow-link" title={followUpUrl}>
          {followUpLabel || "Link"} ‚Üó
        </span>
      )}
      {author && <span class="feed-card__author">‚Äî {author}</span>}
    </div>
  )}
  {locked && <p class="feed-card__desc">üîí ƒê√£ kh√≥a</p>}

  <div class="feed-card__media">
    <img
      src={initialImage}
      alt=""
      loading="eager"
      decoding="async"
      data-candidates={imageCandidates.join("|")}
      data-candidate-index="0"
      data-fallback={fallbackImage}
    />
  </div>
</a>

<script>
  const HEIC_RE = /\.(heic|heif)(?:[?#].*)?$/i;
  const NON_SAFARI_RE = /(chrome|crios|edg|opr|android)/i;
  const convertedImageUrlCache = new Map<string, string>();
  const heicConvertResultCache = new Map<string, boolean>();
  const candidateProbeResultCache = new Map<string, boolean>();
  const candidateProbePromiseCache = new Map<string, Promise<boolean>>();
  let heic2anyLoader: Promise<any> | null = null;

  const loadHeic2any = async () => {
    if (!heic2anyLoader) {
      heic2anyLoader = import("heic2any").then((mod) => mod.default ?? mod);
    }
    return heic2anyLoader;
  };

  const isProbablySafari = () =>
    /safari/i.test(navigator.userAgent) && !NON_SAFARI_RE.test(navigator.userAgent);

  const srcWithAbsUrl = (value: string): string => {
    try {
      return new URL(value, window.location.origin).toString();
    } catch (_error) {
      return value;
    }
  };

  const parseCandidates = (img: HTMLImageElement) => {
    const raw = img.dataset.candidates ?? "";
    const candidates = raw.split("|").filter(Boolean);
    const indexRaw = Number.parseInt(img.dataset.candidateIndex ?? "0", 10);
    const index = Number.isNaN(indexRaw) ? 0 : Math.max(0, Math.min(indexRaw, Math.max(candidates.length - 1, 0)));
    return { candidates, index };
  };

  const setCandidate = (img: HTMLImageElement, index: number, next: string) => {
    img.dataset.candidateIndex = String(index);
    if (img.getAttribute("src") !== next) {
      img.src = next;
    }
  };

  const probeCandidate = async (value: string): Promise<boolean> => {
    const abs = srcWithAbsUrl(value);
    const cached = candidateProbeResultCache.get(abs);
    if (typeof cached === "boolean") return cached;
    const inFlight = candidateProbePromiseCache.get(abs);
    if (inFlight) return inFlight;

    const promise = new Promise<boolean>((resolve) => {
      const probe = new Image();
      let settled = false;
      const done = (ok: boolean) => {
        if (settled) return;
        settled = true;
        candidateProbeResultCache.set(abs, ok);
        candidateProbePromiseCache.delete(abs);
        resolve(ok);
      };
      const timeout = window.setTimeout(() => done(false), 1800);
      probe.onload = () => {
        window.clearTimeout(timeout);
        done((probe.naturalWidth || 0) > 1 && (probe.naturalHeight || 0) > 1);
      };
      probe.onerror = () => {
        window.clearTimeout(timeout);
        done(false);
      };
      probe.src = abs;
    });

    candidateProbePromiseCache.set(abs, promise);
    return promise;
  };

  const findWorkingCandidate = async (
    img: HTMLImageElement,
    startIndex: number,
    { skipHeic }: { skipHeic: boolean }
  ): Promise<boolean> => {
    const { candidates } = parseCandidates(img);
    if (!candidates.length) return false;
    for (let i = Math.max(0, startIndex); i < candidates.length; i += 1) {
      const candidate = candidates[i];
      if (!candidate) continue;
      const abs = srcWithAbsUrl(candidate);
      if (skipHeic && HEIC_RE.test(abs)) continue;
      const ok = await probeCandidate(candidate);
      if (!ok) continue;
      setCandidate(img, i, candidate);
      return true;
    }
    return false;
  };

  const initFeedImageFallbacks = () => {
    const imgs = document.querySelectorAll(".feed-card__media img[data-candidates]");
    imgs.forEach((img) => {
      if (!(img instanceof HTMLImageElement)) return;
      const { index } = parseCandidates(img);
      img.dataset.candidateIndex = String(index);
    });
  };

  const blobIsRenderable = async (blob: Blob): Promise<boolean> => {
    if (!(blob instanceof Blob) || blob.size <= 0) return false;
    let bitmap = null;
    if ("createImageBitmap" in window) {
      try {
        bitmap = await createImageBitmap(blob);
      } catch (_error) {
        bitmap = null;
      }
    }

    if (bitmap && bitmap.width > 1 && bitmap.height > 1) {
      try {
        const sampleW = Math.max(1, Math.min(64, bitmap.width));
        const sampleH = Math.max(1, Math.min(64, bitmap.height));
        const canvas = document.createElement("canvas");
        canvas.width = sampleW;
        canvas.height = sampleH;
        const ctx = canvas.getContext("2d", { willReadFrequently: true });
        if (ctx) {
          ctx.drawImage(bitmap, 0, 0, sampleW, sampleH);
          const data = ctx.getImageData(0, 0, sampleW, sampleH).data;
          const pxCount = sampleW * sampleH;
          let alphaSum = 0;
          let lumSum = 0;
          let lumSqSum = 0;
          for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            const a = data[i + 3];
            alphaSum += a;
            const lum = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            lumSum += lum;
            lumSqSum += lum * lum;
          }
          const alphaAvg = alphaSum / pxCount;
          const lumAvg = lumSum / pxCount;
          const lumVar = lumSqSum / pxCount - lumAvg * lumAvg;
          // Reject transparent/flat-black decodes that appear "successful" but render as empty cards.
          if (alphaAvg > 5 && !(lumAvg < 2 && lumVar < 1)) {
            bitmap.close();
            return true;
          }
        }
      } catch (_error) {
        // fall through to Image decode check
      } finally {
        bitmap.close();
      }
    }

    const objectUrl = URL.createObjectURL(blob);
    try {
      const ok = await new Promise((resolve) => {
        const probe = new Image();
        probe.onload = () => resolve((probe.naturalWidth || 0) > 1 && (probe.naturalHeight || 0) > 1);
        probe.onerror = () => resolve(false);
        probe.src = objectUrl;
      });
      return Boolean(ok);
    } finally {
      URL.revokeObjectURL(objectUrl);
    }
  };

  const convertHeicToJpeg = async (img: HTMLImageElement, source: string): Promise<boolean> => {
    const heicSrc = srcWithAbsUrl(source);
    if (!HEIC_RE.test(heicSrc)) return false;
    const cached = convertedImageUrlCache.get(heicSrc);
    if (cached) {
      img.src = cached;
      return true;
    }

    const known = heicConvertResultCache.get(heicSrc);
    if (known === false) return false;

    const res = await fetch(heicSrc, { credentials: "same-origin" });
    if (!res.ok) {
      heicConvertResultCache.set(heicSrc, false);
      return false;
    }
    const raw = await res.arrayBuffer();
    const sourceBytes = raw.byteLength;
    const typedBlob = new Blob([raw], {
      type: /\.heif(?:[?#].*)?$/i.test(heicSrc) ? "image/heif" : "image/heic",
    });

    const conversionTargets = [
      { toType: "image/jpeg", quality: 0.9 },
      { toType: "image/png", quality: 1 },
    ];
    const heic2any = await loadHeic2any();
    for (const target of conversionTargets) {
      const converted = await heic2any({
        blob: typedBlob,
        toType: target.toType,
        quality: target.quality,
      });
      const outBlob = Array.isArray(converted) ? converted[0] : converted;
      if (!(outBlob instanceof Blob)) continue;

      // Broken HEIC decodes sometimes yield tiny unusable blobs.
      if (sourceBytes > 256 * 1024 && outBlob.size < 8 * 1024) continue;
      const renderable = await blobIsRenderable(outBlob);
      if (!renderable) continue;

      const objectUrl = URL.createObjectURL(outBlob);
      convertedImageUrlCache.set(heicSrc, objectUrl);
      heicConvertResultCache.set(heicSrc, true);
      img.src = objectUrl;
      return true;
    }
    heicConvertResultCache.set(heicSrc, false);
    return false;
  };

  const recoverImage = async (
    img: HTMLImageElement,
    { fromError }: { fromError: boolean }
  ) => {
    if (img.dataset.recovering === "1") return;
    img.dataset.recovering = "1";
    try {
      const { candidates, index } = parseCandidates(img);
      if (!candidates.length) {
        img.src = img.dataset.fallback || "/collage/moodboard.jpg";
        return;
      }

      const startIndex = fromError ? Math.min(index + 1, candidates.length - 1) : index;
      const skipHeic = !isProbablySafari();
      const foundStatic = await findWorkingCandidate(img, startIndex, { skipHeic });
      if (foundStatic) return;

      if (!skipHeic) {
        const foundHeic = await findWorkingCandidate(img, startIndex, { skipHeic: false });
        if (foundHeic) return;
      }

      for (const candidate of candidates) {
        if (!candidate) continue;
        if (!HEIC_RE.test(srcWithAbsUrl(candidate))) continue;
        try {
          const converted = await convertHeicToJpeg(img, candidate);
          if (converted) return;
        } catch (_error) {
          // continue through next HEIC candidate
        }
      }

      img.src = img.dataset.fallback || "/collage/moodboard.jpg";
    } finally {
      img.dataset.recovering = "0";
    }
  };

  const primeBrokenFeedImages = async () => {
    const imgs = document.querySelectorAll(".feed-card__media img[data-candidates]");
    const tasks: Promise<void>[] = [];
    for (const img of imgs) {
      if (!(img instanceof HTMLImageElement)) continue;
      if (!img.complete) continue;
      if ((img.naturalWidth || 0) > 1 && (img.naturalHeight || 0) > 1) continue;
      tasks.push(recoverImage(img, { fromError: false }));
    }
    if (tasks.length) await Promise.allSettled(tasks);
  };

  if (!(window as any).__twawFeedImageFallbackBound) {
    document.addEventListener(
      "error",
      (event) => {
        const target = event.target;
        if (!(target instanceof HTMLImageElement)) return;
        if (!target.matches(".feed-card__media img[data-candidates]")) return;
        void recoverImage(target, { fromError: true });
      },
      true,
    );
    (window as any).__twawFeedImageFallbackBound = true;
  }

  initFeedImageFallbacks();
  window.setTimeout(() => {
    void primeBrokenFeedImages();
  }, 300);
  window.setTimeout(() => {
    void primeBrokenFeedImages();
  }, 1600);
  window.setTimeout(() => {
    void primeBrokenFeedImages();
  }, 3600);
  document.addEventListener("astro:page-load", initFeedImageFallbacks);
  document.addEventListener("astro:page-load", () => {
    window.setTimeout(() => {
      void primeBrokenFeedImages();
    }, 300);
    window.setTimeout(() => {
      void primeBrokenFeedImages();
    }, 1600);
    window.setTimeout(() => {
      void primeBrokenFeedImages();
    }, 3600);
  });
</script>
