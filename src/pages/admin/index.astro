---
import BaseLayout from "../../layouts/BaseLayout.astro";
import RansomTitle from "../../components/RansomTitle.astro";
import { TOPICS } from "../../config/topics";
import { COMMENT_STATUSES } from "../../lib/constants";

export const prerender = false;

const enablePinnedFields = import.meta.env.PUBLIC_ENABLE_PINNED_FIELDS !== "false";
const enableUploadHelpers = import.meta.env.PUBLIC_ENABLE_UPLOAD_HELPERS !== "false";
const commentStatusLabels: Record<(typeof COMMENT_STATUSES)[number], string> = {
  pending: "Ch·ªù duy·ªát",
  visible: "ƒê√£ duy·ªát",
  hidden: "·∫®n",
};
---

<BaseLayout title="Admin ‚Äî Two Against The World" description="Admin dashboard">
  <main class="mx-auto max-w-7xl px-5 pb-24 pt-10">
    <section class="paper edge-torn p-6 sm:p-10" data-reveal>
      <div class="kicker text-xs text-black/50">ADMIN</div>
      <RansomTitle text="Publish l√† l√™n ngay" as="h1" class="text-[44px] sm:text-[56px]" />
      <p class="mt-3 text-black/60">
        Qu·∫£n l√Ω b√†i vi·∫øt t·ª´ ƒëi·ªán tho·∫°i: t·∫°o draft, l∆∞u v√† publish ngay l·∫≠p t·ª©c.
      </p>
    </section>

    <section class="mt-10 grid gap-8 lg:grid-cols-[1fr_2fr]">
      <div class="paper edge-torn p-6 sm:p-8" data-reveal>
        <div class="flex items-center justify-between">
          <h2 class="text-lg font-semibold">Danh s√°ch b√†i</h2>
          <button class="btn" type="button" data-new-post>T·∫°o b√†i m·ªõi</button>
        </div>
        <div class="mt-4 space-y-3" data-post-list></div>
      </div>

      <div class="paper edge-torn p-6 sm:p-8" data-reveal>
        <div class="flex flex-wrap items-center gap-3">
          <h2 class="text-lg font-semibold">So·∫°n b√†i</h2>
          <span class="text-xs text-black/50" data-post-status>Ch∆∞a ch·ªçn b√†i</span>
        </div>
        <div class="mt-4 space-y-3" data-admin-auth>
          <div data-auth-locked>
            <p class="text-xs text-black/60">
              ƒêƒÉng nh·∫≠p ƒë·ªÉ m·ªü kh√≥a so·∫°n b√†i & upload. Tr·∫°ng th√°i:
              <span data-admin-status>ƒêang kh√≥a</span>
            </p>
            <div class="flex flex-wrap items-center gap-3">
              <input
                class="input"
                type="password"
                name="admin_password"
                placeholder="Admin password"
                data-admin-password
              />
              <button class="btn" type="button" data-admin-login>M·ªü kh√≥a</button>
            </div>
          </div>
          <div class="hidden" data-auth-unlocked>
            <p class="text-xs text-black/60">
              ƒê√£ ƒëƒÉng nh·∫≠p. <span data-admin-status>ƒê√£ m·ªü kh√≥a</span>
            </p>
            <button class="btn" type="button" data-admin-logout>ƒêƒÉng xu·∫•t</button>
          </div>
        </div>
        <div class="admin-toast" data-admin-toast role="status" aria-live="polite" aria-atomic="true"></div>

        <form class="mt-4 space-y-4" data-post-form>
          <p class="text-xs text-black/60">
            Tr∆∞·ªùng c√≥ <span class="text-red-500">*</span> l√† b·∫Øt bu·ªôc. B·∫Øt bu·ªôc t·ªëi thi·ªÉu: Ti√™u ƒë·ªÅ, Ch·ªß ƒë·ªÅ,
            T√°c gi·∫£, N·ªôi dung v√† √≠t nh·∫•t 1 media (·∫£nh ho·∫∑c video).
          </p>
          <input type="hidden" name="id" />

          <label class="compose-field">
            <span>Ti√™u ƒë·ªÅ <span class="text-red-500">*</span></span>
            <input class="input" name="title" placeholder="Ti√™u ƒë·ªÅ b√†i vi·∫øt" required />
          </label>

          <div class="compose-field hidden" data-link-preview>
            <span>Link b√†i vi·∫øt</span>
            <div class="flex flex-wrap items-center gap-2">
              <input class="input flex-1 min-w-[220px]" type="text" readonly data-link-text />
              <button class="btn" type="button" data-link-open>M·ªü</button>
              <button class="btn" type="button" data-link-copy>Sao ch√©p</button>
            </div>
            <p class="mt-2 text-xs text-black/50">
              Link s·∫Ω hi·ªán sau khi l∆∞u ho·∫∑c publish.
            </p>
          </div>

          <label class="compose-field">
            <span>Ch·ªß ƒë·ªÅ <span class="text-red-500">*</span></span>
            <select class="input" name="topic" required>
              <option value="">Ch∆∞a ph√¢n lo·∫°i</option>
              {TOPICS.map((t) => (
                <option value={t.slug}>{t.label}</option>
              ))}
            </select>
          </label>

          <label class="compose-field">
            <span>T√°c gi·∫£ <span class="text-red-500">*</span></span>
            <input
              class="input"
              name="author"
              placeholder="nh√† tri·∫øt h·ªçc tr√™n gi∆∞·ªùng | nh√† tri·∫øt h·ªçc ·ªü h·ªôp ƒë√™m"
              required
            />
          </label>

          <div class="compose-field">
            <span>·∫¢nh (tu·ª≥ ch·ªçn cho b√†i video)</span>
            <input type="hidden" name="cover_key" />
            <input type="hidden" name="cover_url" />
            <input
              class="input"
              type="file"
              name="upload_photos"
              accept="image/*,image/heic,image/heif"
              multiple
              data-upload-input
            />
            <p class="mt-2 text-xs text-black/50">N·∫øu l√† b√†i video th√¨ c√≥ th·ªÉ b·ªè qua ·∫£nh n√†y.</p>
            <p class="text-xs text-black/50">·∫¢nh HEIC/HEIF t·ª´ iPhone ƒë∆∞·ª£c gi·ªØ nguy√™n, kh√¥ng t·ª± convert tr∆∞·ªõc khi upload.</p>
            <div class="compose-preview" data-upload-preview></div>
            {enableUploadHelpers && <button class="btn hidden mt-3" type="button" data-upload-cancel>H·ªßy</button>}
            {enableUploadHelpers && <p class="text-xs text-black/50" data-upload-progress></p>}
            <p class="text-xs text-black/50" data-upload-note></p>
          </div>

          <label class="compose-field">
            <span>N·ªôi dung (Markdown) <span class="text-red-500">*</span></span>
            <textarea
              class="input compose-textarea"
              name="content_md"
              rows={12}
              placeholder="Vi·∫øt n·ªôi dung..."
              required
            ></textarea>
          </label>
          <div class="compose-field">
            <button class="btn" type="button" data-preview-toggle>Xem preview</button>
            <div class="mt-3 hidden prose prose-scrap max-w-none" data-preview></div>
          </div>

          <details class="compose-advanced">
            <summary class="compose-advanced__summary">N√¢ng cao (tu·ª≥ ch·ªçn)</summary>
            <div class="mt-4 grid gap-4">
              <label class="compose-field">
                <span>ƒê∆∞·ªùng d·∫´n b√†i vi·∫øt</span>
                <input class="input" name="slug" placeholder="vi-du-duong-dan-bai-viet" />
                <p class="mt-2 text-xs text-black/50">
                  T·ª± t·∫°o t·ª´ ti√™u ƒë·ªÅ n·∫øu b·ªè tr·ªëng. S·∫Ω b·ªè d·∫•u v√† thay kho·∫£ng tr·∫Øng b·∫±ng d·∫•u g·∫°ch ngang.
                </p>
              </label>

              <label class="compose-field">
                <span>T√≥m t·∫Øt (kh√¥ng ch√®n link)</span>
                <input class="input" name="summary" placeholder="M·ªôt c√¢u gi·ªõi thi·ªáu ng·∫Øn, kh√¥ng d√°n URL" />
                <p class="mt-2 text-xs text-black/50">
                  Ghi ch√∫: Ph·∫ßn t√≥m t·∫Øt ch·ªâ ƒë·ªÉ m√¥ t·∫£ ng·∫Øn. Kh√¥ng nh·∫≠p link video hay link ngo√†i.
                </p>
              </label>

              <label class="compose-field">
                <span>ƒê·ªãa ƒëi·ªÉm</span>
                <input class="input" name="location" placeholder="ƒê·ªãa ƒëi·ªÉm" />
              </label>

              <label class="compose-field">
                <span>Th·ªùi gian s·ª± ki·ªán</span>
                <input class="input" name="event_time" placeholder="20:30 - 21:00" />
              </label>

              <label class="compose-field">
                <span>Vi·∫øt l√∫c</span>
                <input class="input" name="written_at" placeholder="21/02/2026" />
              </label>

              <label class="compose-field">
                <span>Ch·ª•p l√∫c</span>
                <input class="input" name="photo_time" placeholder="21/02/2026" />
              </label>

              <label class="compose-field">
                <span>Tags (ph√¢n t√°ch b·∫±ng d·∫•u ph·∫©y)</span>
                <input class="input" name="tags_csv" placeholder="memory, love" />
              </label>

              <label class="compose-field">
                <span>Ghi ch√∫ th√™m</span>
                <input class="input" name="side_note" placeholder="M·ªôt c√¢u th√™m" />
              </label>

              <label class="compose-field">
                <span>Voice memo (URL)</span>
                <input class="input" name="voice_memo" placeholder="https://..." />
              </label>

              <label class="compose-field">
                <span>Ti√™u ƒë·ªÅ voice memo</span>
                <input class="input" name="voice_memo_title" placeholder="T√™n ƒëo·∫°n ghi √¢m" />
              </label>

              <div class="compose-field">
                <span>Video file (Cloudflare Stream)</span>
                <input class="input" type="file" name="upload_video" accept="video/*" data-video-upload-input />
                <div class="mt-2 flex flex-wrap gap-2">
                  <button class="btn" type="button" data-video-upload-start>Upload video</button>
                  <button class="btn hidden" type="button" data-video-upload-cancel>H·ªßy upload video</button>
                </div>
                <p class="mt-2 text-xs text-black/50" data-video-upload-progress></p>
                <p class="text-xs text-black/50" data-video-upload-note>
                  Upload tr·ª±c ti·∫øp l√™n Cloudflare Stream ƒë·ªÉ tr√°nh gi·ªõi h·∫°n Worker. Kh√¥ng c·∫ßn ·∫£nh b√¨a ri√™ng.
                </p>
              </div>

              <label class="compose-field">
                <span>Video URL</span>
                <input class="input" name="video_url" placeholder="Cloudflare Stream UID / watch URL / iframe URL" />
              </label>

              <label class="compose-field">
                <span>Video poster (URL)</span>
                <input class="input" name="video_poster" placeholder="https://..." />
              </label>

              {enablePinnedFields && (
                <>
                  <label class="compose-field">
                    <span>Ghim b√†i</span>
                    <select class="input" name="pinned">
                      <option value="0">Kh√¥ng</option>
                      <option value="1">C√≥</option>
                    </select>
                  </label>

                  <label class="compose-field">
                    <span>ƒê·ªô ∆∞u ti√™n ghim</span>
                    <input class="input" name="pinned_priority" type="number" min="0" max="999" placeholder="0" />
                  </label>

                  <label class="compose-field">
                    <span>Ghim ƒë·∫øn (ISO)</span>
                    <input class="input" name="pinned_until" placeholder="2026-02-02T10:00:00Z" />
                  </label>

                  <label class="compose-field">
                    <span>Ki·ªÉu ghim</span>
                    <select class="input" name="pinned_style">
                      <option value="">M·∫∑c ƒë·ªãnh</option>
                      <option value="event">Event</option>
                      <option value="announcement">Announcement</option>
                      <option value="memory">Memory</option>
                    </select>
                  </label>
                </>
              )}

              <label class="compose-field">
                <span>Ng√†y & gi·ªù ƒëƒÉng</span>
                <input class="input" name="published_at_local" type="datetime-local" step="60" />
                <p class="mt-2 text-xs text-black/50">
                  L·∫•y theo gi·ªù thi·∫øt b·ªã: <span data-device-timezone>ƒêang ƒë·ªçc...</span>
                </p>
              </label>

              <label class="compose-field">
                <span>Layout</span>
                <select class="input" name="layout">
                  <option value="normal">Normal</option>
                  <option value="long">Long</option>
                </select>
              </label>

              <label class="compose-field">
                <span>Th·ª© t·ª± hi·ªÉn th·ªã</span>
                <input class="input" name="sort_order" type="number" min="-9999" max="9999" placeholder="0" />
              </label>

              <label class="compose-field">
                <span>Tr·∫°ng th√°i</span>
                <select class="input" name="status">
                  <option value="draft">Draft</option>
                  <option value="published">Published</option>
                  <option value="archived">Archived</option>
                </select>
              </label>
            </div>
          </details>

          <div class="flex flex-wrap gap-3">
            <button class="btn" type="submit" data-save-post>L∆∞u</button>
            <button class="btn" type="button" data-submit-post>ƒêƒÉng b√†i ngay</button>
            <button class="btn" type="button" data-publish-post>Publish</button>
            <button class="btn" type="button" data-unpublish-post>G·ª° publish</button>
            <button class="btn" type="button" data-delete-post>X√≥a</button>
          </div>
          <p class="text-xs text-black/50" data-form-note></p>
        </form>
      </div>
    </section>

    <section class="mt-10 grid gap-8 lg:grid-cols-[1fr_2fr]">
      <div class="paper edge-torn p-6 sm:p-8" data-reveal>
        <div class="flex items-center justify-between">
          <h2 class="text-lg font-semibold">B√¨nh lu·∫≠n</h2>
          <select class="input text-sm" data-comment-filter>
            {COMMENT_STATUSES.map((status) => (
              <option value={status}>{commentStatusLabels[status]}</option>
            ))}
            <option value="">T·∫•t c·∫£</option>
          </select>
        </div>
        <div class="mt-4 space-y-3" data-comment-list></div>
      </div>
      <div class="paper edge-torn p-6 sm:p-8" data-reveal>
        <h2 class="text-lg font-semibold">Moderation</h2>
        <p class="mt-2 text-xs text-black/60">
          Ch·ªçn tr·∫°ng th√°i ƒë·ªÉ hi·ªÉn th·ªã ho·∫∑c ·∫©n comment sau khi ƒë√£ ƒëƒÉng.
        </p>
        <p class="mt-4 text-xs text-black/50" data-comment-note></p>
      </div>
    </section>
  </main>

  <script>
    // @ts-nocheck
    import { marked } from "marked";

    const slugify = (s = "") =>
      s
        .toLowerCase()
        .replace(/ƒë/g, "d")
        .normalize("NFKD")
        .replace(/[^\w\s-]/g, "")
        .trim()
        .replace(/\s+/g, "-")
        .replace(/-+/g, "-");

    const form = document.querySelector("[data-post-form]");
    const list = document.querySelector("[data-post-list]");
    const status = document.querySelector("[data-post-status]");
    const note = document.querySelector("[data-form-note]");
    const newBtn = document.querySelector("[data-new-post]");
    const publishBtn = document.querySelector("[data-publish-post]");
    const unpublishBtn = document.querySelector("[data-unpublish-post]");
    const submitBtn = document.querySelector("[data-submit-post]");
    const deleteBtn = document.querySelector("[data-delete-post]");
    const uploadInput = document.querySelector("[data-upload-input]");
    const uploadPreview = document.querySelector("[data-upload-preview]");
    const uploadNote = document.querySelector("[data-upload-note]");
    const uploadProgress = document.querySelector("[data-upload-progress]");
    const uploadCancel = document.querySelector("[data-upload-cancel]");
    const videoUploadInput = document.querySelector("[data-video-upload-input]");
    const videoUploadStart = document.querySelector("[data-video-upload-start]");
    const videoUploadCancel = document.querySelector("[data-video-upload-cancel]");
    const videoUploadNote = document.querySelector("[data-video-upload-note]");
    const videoUploadProgress = document.querySelector("[data-video-upload-progress]");
    const authWrap = document.querySelector("[data-admin-auth]");
    const lockStatus = document.querySelector("[data-admin-status]");
    const passwordInput = document.querySelector("[data-admin-password]");
    const loginBtn = document.querySelector("[data-admin-login]");
    const logoutBtn = document.querySelector("[data-admin-logout]");
    const authLocked = document.querySelector("[data-auth-locked]");
    const authUnlocked = document.querySelector("[data-auth-unlocked]");
    const previewToggle = document.querySelector("[data-preview-toggle]");
    const previewEl = document.querySelector("[data-preview]");
    const adminToast = document.querySelector("[data-admin-toast]");
    const linkPreview = document.querySelector("[data-link-preview]");
    const linkText = document.querySelector("[data-link-text]");
    const linkOpen = document.querySelector("[data-link-open]");
    const linkCopy = document.querySelector("[data-link-copy]");
    const commentList = document.querySelector("[data-comment-list]");
    const commentFilter = document.querySelector("[data-comment-filter]");
    const commentNote = document.querySelector("[data-comment-note]");
    const deviceTimezoneEls = Array.from(document.querySelectorAll("[data-device-timezone]"));
    let unlocked = false;
    const enableDraftSave = import.meta.env.PUBLIC_ENABLE_ADMIN_DRAFT_SAVE !== "false";
    const enableUploadHelpers = import.meta.env.PUBLIC_ENABLE_UPLOAD_HELPERS !== "false";
    const MAX_UPLOAD_FILES = 6;
    const MAX_FILE_BYTES = 2.5 * 1024 * 1024;
    const MAX_VIDEO_FILE_BYTES = 50 * 1024 * 1024 * 1024;
    let uploadController = null;
    let videoUploadController = null;
    let selectedFiles = [];
    let previewUrls = [];
    let coverIndex = 0;
    let uploadBatchId = null;

    const state = {
      posts: [],
      active: null,
      dirty: false,
    };
    let renderPreview = () => {};
    let clearPreviewUrls = () => {};

    const markDirty = () => {
      state.dirty = true;
    };

    const setLocked = (locked) => {
      if (lockStatus) {
        lockStatus.textContent = locked ? "ƒêang kh√≥a" : "ƒê√£ m·ªü kh√≥a";
      }
      authWrap?.classList.toggle("opacity-60", locked);
      authLocked?.classList.toggle("hidden", !locked);
      authUnlocked?.classList.toggle("hidden", locked);
      const controls = [
        newBtn,
        publishBtn,
        unpublishBtn,
        submitBtn,
        deleteBtn,
        ...(form ? Array.from(form.querySelectorAll("input, textarea, select, button")) : []),
      ].filter(Boolean);
      controls.forEach((el) => {
        if (
          el?.hasAttribute("data-admin-login") ||
          el?.hasAttribute("data-admin-logout") ||
          el?.hasAttribute("data-admin-password")
        )
          return;
        el.disabled = locked;
      });
    };

    const isUnlocked = () => unlocked;

    let toastTimeout = null;
    const formatApiError = (payload, fallback) => {
      const message = [payload?.error, payload?.detail].filter(Boolean).join(" ‚Äî ");
      return message || fallback;
    };
    const showToast = (message, variant = "error") => {
      if (!adminToast) return;
      adminToast.textContent = message;
      adminToast.dataset.state = variant;
      adminToast.classList.add("is-visible");
      if (toastTimeout) window.clearTimeout(toastTimeout);
      toastTimeout = window.setTimeout(() => {
        adminToast.classList.remove("is-visible");
        adminToast.textContent = "";
        adminToast.dataset.state = "";
      }, 2200);
    };

    const getCsrfToken = () => {
      const match = document.cookie.match(/(?:^|; )twaw_admin_csrf=([^;]+)/);
      return match ? decodeURIComponent(match[1]) : "";
    };

    const getSiteBase = () => import.meta.env.PUBLIC_SITE_URL || window.location.origin;

    const formatUtcOffset = (offsetMinutes) => {
      if (!Number.isFinite(offsetMinutes)) return "";
      const sign = offsetMinutes >= 0 ? "+" : "-";
      const absMinutes = Math.abs(Math.trunc(offsetMinutes));
      const hours = String(Math.floor(absMinutes / 60)).padStart(2, "0");
      const minutes = String(absMinutes % 60).padStart(2, "0");
      return `${sign}${hours}:${minutes}`;
    };

    const getDeviceTimeZone = () =>
      Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC";

    const getDeviceOffsetLabel = () => {
      const offsetMinutes = -new Date().getTimezoneOffset();
      return `UTC${formatUtcOffset(offsetMinutes)}`;
    };

    const getDeviceTimeZoneLabel = () => `${getDeviceTimeZone()} (${getDeviceOffsetLabel()})`;

    const toLocalDateTimeInput = (value) => {
      const date = value instanceof Date ? value : new Date(value);
      if (Number.isNaN(date.getTime())) return "";
      const pad = (n) => String(n).padStart(2, "0");
      const year = date.getFullYear();
      const month = pad(date.getMonth() + 1);
      const day = pad(date.getDate());
      const hours = pad(date.getHours());
      const minutes = pad(date.getMinutes());
      return `${year}-${month}-${day}T${hours}:${minutes}`;
    };

    const toIsoFromLocalDateTime = (value) => {
      if (!value) return null;
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return null;
      return date.toISOString();
    };

    const VIDEO_URL_RE = /\.(mp4|m4v|mov|webm|ogv|ogg|m3u8)(?:[?#].*)?$/i;
    const STREAM_UID_RE = /^[a-f0-9]{32}$/i;
    const STREAM_HOST_RE = /(^|\.)videodelivery\.net$/i;
    const STREAM_HOST_ALT_RE = /(^|\.)cloudflarestream\.com$/i;

    const normalizeVideoUrl = (value) => String(value || "").trim();

    const looksLikeStreamVideo = (raw) => {
      if (!raw) return false;
      if (STREAM_UID_RE.test(raw)) return true;
      try {
        const parsed = new URL(raw);
        if (!STREAM_HOST_RE.test(parsed.hostname) && !STREAM_HOST_ALT_RE.test(parsed.hostname)) {
          return false;
        }
        if (/\/[a-f0-9]{32}(?:[/?#]|$)/i.test(parsed.pathname)) return true;
        const fromQuery = (parsed.searchParams.get("video") || "").trim();
        return STREAM_UID_RE.test(fromQuery);
      } catch {
        if (/^[a-z0-9.-]+\.[a-z]{2,}\/?/i.test(raw)) {
          try {
            const parsed = new URL(`https://${raw}`);
            if (!STREAM_HOST_RE.test(parsed.hostname) && !STREAM_HOST_ALT_RE.test(parsed.hostname)) {
              return false;
            }
            if (/\/[a-f0-9]{32}(?:[/?#]|$)/i.test(parsed.pathname)) return true;
            const fromQuery = (parsed.searchParams.get("video") || "").trim();
            return STREAM_UID_RE.test(fromQuery);
          } catch {
            return false;
          }
        }
        return false;
      }
    };

    const isLikelyVideoUrl = (value) => {
      const raw = normalizeVideoUrl(value);
      if (!raw) return false;
      if (looksLikeStreamVideo(raw)) return true;
      if (VIDEO_URL_RE.test(raw)) return true;
      if (raw.startsWith("/videos/")) return true;
      try {
        const parsed = new URL(raw);
        if (VIDEO_URL_RE.test(parsed.pathname)) return true;
        if (/^\/videos\//i.test(parsed.pathname)) return true;
      } catch {
        if (/^[a-z0-9.-]+\.[a-z]{2,}\/?/i.test(raw)) {
          try {
            const parsed = new URL(`https://${raw}`);
            if (VIDEO_URL_RE.test(parsed.pathname)) return true;
            if (/^\/videos\//i.test(parsed.pathname)) return true;
          } catch {
            return false;
          }
        }
      }
      return false;
    };

    const parseCommentDate = (value) => {
      if (typeof value !== "string") return null;
      const raw = value.trim();
      if (!raw) return null;
      let normalized = raw;
      if (/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/.test(raw)) {
        normalized = `${raw.replace(" ", "T")}Z`;
      } else if (
        /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?$/.test(raw)
      ) {
        normalized = `${raw}Z`;
      }
      const parsed = new Date(normalized);
      return Number.isNaN(parsed.getTime()) ? null : parsed;
    };

    const getPostedZoneLabel = (timeZone) => {
      const tz = typeof timeZone === "string" ? timeZone.trim() : "";
      if (tz === "Asia/Ho_Chi_Minh" || tz === "Asia/Saigon") return "üáªüá≥ Gi·ªù Vi·ªát";
      if (tz === "Asia/Tokyo") return "üáØüáµ Gi·ªù Nh·∫≠t";
      if (tz.startsWith("America/") || tz === "Pacific/Honolulu") return "üá∫üá∏ Gi·ªù M·ªπ";
      return "";
    };

    const formatCommentTime = (item = {}) => {
      const clientLocal = parseCommentDate(item.client_local_at);
      const tz = typeof item.client_time_zone === "string" ? item.client_time_zone.trim() : "";
      if (clientLocal) {
        const text = tz
          ? clientLocal.toLocaleString("vi-VN", { timeZone: tz })
          : clientLocal.toLocaleString("vi-VN");
        const label = getPostedZoneLabel(tz);
        return label ? `${text} (${label})` : text;
      }
      const createdAt = parseCommentDate(item.created_at);
      return createdAt ? createdAt.toLocaleString("vi-VN") : "‚Äî";
    };

    const setLoginLoading = (isLoading) => {
      if (loginBtn) loginBtn.disabled = isLoading;
      if (passwordInput) passwordInput.disabled = isLoading;
    };

    const getSlugValue = () => {
      const slugInput = form?.querySelector("[name='slug']");
      const rawSlug = slugInput?.value?.trim();
      if (rawSlug) return slugify(rawSlug);
      const titleValue = form?.querySelector("[name='title']")?.value ?? "";
      return slugify(titleValue);
    };

    const updateLinkPreview = () => {
      if (!linkPreview || !linkText) return;
      const hasId = Boolean(form?.querySelector("[name='id']")?.value);
      if (!hasId) {
        linkPreview.classList.add("hidden");
        linkText.value = "";
        if (linkOpen) linkOpen.disabled = true;
        return;
      }
      const slugValue = getSlugValue();
      if (!slugValue) {
        linkPreview.classList.add("hidden");
        linkText.value = "";
        if (linkOpen) linkOpen.disabled = true;
        return;
      }
      const base = getSiteBase();
      linkText.value = base.replace(/\/$/, "") + "/entries/" + slugValue;
      linkPreview.classList.remove("hidden");
      if (linkOpen) linkOpen.disabled = false;
    };

    const login = async () => {
      if (!passwordInput?.value) {
        lockStatus.textContent = "Nh·∫≠p password";
        showToast("Nh·∫≠p password ƒë·ªÉ m·ªü kh√≥a.");
        return;
      }
      setLoginLoading(true);
      try {
        const res = await fetch("/api/admin/unlock", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ password: passwordInput.value }),
        });
        const payload = await res.json().catch(() => ({}));
        if (!res.ok) {
          lockStatus.textContent = "Kh√¥ng m·ªü kh√≥a ƒë∆∞·ª£c";
          const hint = [payload?.howToFixProd, payload?.howToFixLocal].filter(Boolean).join(" | ");
          const message = formatApiError(payload, "Kh√¥ng m·ªü kh√≥a ƒë∆∞·ª£c. Th·ª≠ l·∫°i nh√©.");
          showToast(hint ? `${message} (${hint})` : message);
          setLocked(true);
          return;
        }
        unlocked = Boolean(payload?.authenticated);
        if (!unlocked) {
          lockStatus.textContent = "Kh√¥ng m·ªü kh√≥a ƒë∆∞·ª£c";
          showToast("Kh√¥ng m·ªü kh√≥a ƒë∆∞·ª£c. Th·ª≠ l·∫°i nh√©.");
          setLocked(true);
          return;
        }
        passwordInput.value = "";
        setLocked(false);
        await loadPosts();
        await loadComments();
      } finally {
        setLoginLoading(false);
      }
    };

    const checkSession = async () => {
      const res = await fetch("/api/admin/session");
      if (!res.ok) {
        unlocked = false;
        setLocked(true);
        return;
      }
      const data = await res.json().catch(() => ({}));
      unlocked = Boolean(data?.authenticated);
      setLocked(!unlocked);
      if (unlocked) {
        await loadPosts();
        await loadComments();
      }
    };

    loginBtn?.addEventListener("click", login);
    passwordInput?.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        login();
      }
    });
    logoutBtn?.addEventListener("click", async () => {
      await fetch("/api/admin/logout", { method: "POST" });
      unlocked = false;
      setLocked(true);
    });

    linkCopy?.addEventListener("click", async () => {
      if (!linkText?.value) return;
      try {
        await navigator.clipboard.writeText(linkText.value);
        showToast("ƒê√£ sao ch√©p link.", "info");
      } catch {
        showToast("Kh√¥ng sao ch√©p ƒë∆∞·ª£c link.", "error");
      }
    });

    linkOpen?.addEventListener("click", () => {
      if (!linkText?.value) return;
      window.open(linkText.value, "_blank", "noopener,noreferrer");
    });

    const fields = [
      "id",
      "title",
      "slug",
      "summary",
      "cover_key",
      "cover_url",
      "topic",
      "author",
      "location",
      "event_time",
      "written_at",
      "photo_time",
      "tags_csv",
      "side_note",
      "voice_memo",
      "voice_memo_title",
      "video_url",
      "video_poster",
      "pinned",
      "pinned_priority",
      "pinned_until",
      "pinned_style",
      "published_at_local",
      "layout",
      "sort_order",
      "status",
      "content_md",
    ];

    const DRAFT_KEY = "twaw_admin_draft_v1";

    const saveDraft = () => {
      if (!form || !enableDraftSave) return;
      if (state.active?.id) return;
      const data = {};
      fields.forEach((name) => {
        const input = form.querySelector(`[name="${name}"]`);
        if (!input) return;
        data[name] = input.value;
      });
      localStorage.setItem(DRAFT_KEY, JSON.stringify({ data, savedAt: Date.now() }));
    };

    const loadDraft = () => {
      if (!form || state.active?.id || !enableDraftSave) return;
      const raw = localStorage.getItem(DRAFT_KEY);
      if (!raw) return;
      let payload = null;
      try {
        payload = JSON.parse(raw);
      } catch {
        return;
      }
      if (!payload?.data) return;
      fields.forEach((name) => {
        const input = form.querySelector(`[name="${name}"]`);
        if (!input || payload.data[name] === undefined) return;
        input.value = payload.data[name];
      });
      const publishInput = form.querySelector("[name='published_at_local']");
      if (publishInput && !publishInput.value) {
        publishInput.value = toLocalDateTimeInput(new Date());
      }
      status.textContent = "ƒêang d√πng b·∫£n nh√°p tr√™n m√°y";
      updateLinkPreview();
    };

    const clearDraft = () => {
      localStorage.removeItem(DRAFT_KEY);
    };

    const renderDeviceTimeZone = () => {
      const label = getDeviceTimeZoneLabel();
      deviceTimezoneEls.forEach((el) => {
        el.textContent = label;
      });
    };

    const fillForm = (post = {}) => {
      fields.forEach((name) => {
        const input = form.querySelector(`[name="${name}"]`);
        if (!input) return;
        if (name === "author") {
          input.value = post.author ?? post.author_name ?? "";
          return;
        }
        if (name === "content_md") {
          input.value = post.content_md ?? post.body_markdown ?? "";
          return;
        }
        if (name === "published_at_local") {
          const publishedAt = post.published_at ?? post.created_at ?? null;
          input.value = publishedAt ? toLocalDateTimeInput(publishedAt) : toLocalDateTimeInput(new Date());
          return;
        }
        input.value = post[name] ?? (input.type === "number" ? 0 : "");
      });
      if (uploadInput) uploadInput.value = "";
      selectedFiles = [];
      renderPreview();
      state.dirty = false;
      status.textContent = post.status
        ? `Tr·∫°ng th√°i: ${post.status}`
        : "Ch∆∞a ch·ªçn b√†i";
      updateLinkPreview();
    };

    const renderList = () => {
      if (!list) return;
      if (!state.posts.length) {
        list.innerHTML = "<p class='text-sm text-black/50'>Ch∆∞a c√≥ b√†i n√†o.</p>";
        return;
      }
      list.innerHTML = state.posts
        .map(
          (post) => `
            <button type="button" class="w-full text-left border border-black/10 rounded-2xl p-4 hover:border-black/30" data-post-id="${post.id}">
              <div class="text-xs text-black/50">${post.status}</div>
              <div class="font-semibold">${post.title}</div>
              <div class="text-xs text-black/50">${post.slug}</div>
            </button>
          `
        )
        .join("");
      list.querySelectorAll("[data-post-id]").forEach((btn) => {
        btn.addEventListener("click", () => {
          const id = btn.dataset.postId;
          state.active = state.posts.find((p) => p.id === id);
          fillForm(state.active);
        });
      });
    };

    const loadPosts = async () => {
      if (!isUnlocked()) return;
      const res = await fetch("/api/admin/posts");
      if (!res.ok) {
        if (res.status === 401) {
          unlocked = false;
          setLocked(true);
        }
        const payload = await res.json().catch(() => ({}));
        showToast(formatApiError(payload, "Kh√¥ng t·∫£i ƒë∆∞·ª£c b√†i vi·∫øt."));
        return;
      }
      const data = await res.json();
      state.posts = data.posts || [];
      renderList();
    };

    const loadComments = async () => {
      if (!commentList || !isUnlocked()) return;
      const filter = commentFilter?.value ?? "visible";
      const res = await fetch(`/api/admin/comments?status=${encodeURIComponent(filter)}`);
      if (!res.ok) {
        const payload = await res.json().catch(() => ({}));
        showToast(formatApiError(payload, "Kh√¥ng t·∫£i ƒë∆∞·ª£c comment."));
        return;
      }
      const data = await res.json();
      const items = data.comments || [];
      const escapeHtml = (value = "") =>
        String(value)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      if (!items.length) {
        commentList.innerHTML = "<p class='text-sm text-black/50'>Ch∆∞a c√≥ comment.</p>";
        return;
      }
      commentList.innerHTML = items
        .map(
          (item) => `
            <div class="comment-card">
              <div class="comment-meta">
                <span class="comment-name">${escapeHtml(item.display_name || "·∫®n danh")}</span>
                <span class="comment-time">${escapeHtml(formatCommentTime(item))}</span>
                <span class="comment-nick">${escapeHtml(item.post_slug)}</span>
              </div>
              <p class="comment-body">${escapeHtml(item.body)}</p>
              <div class="mt-3 flex flex-wrap gap-2">
                <button class="btn text-xs" data-comment-action="visible" data-comment-id="${item.id}">Duy·ªát</button>
                <button class="btn text-xs" data-comment-action="hidden" data-comment-id="${item.id}">·∫®n</button>
                <button class="btn text-xs" data-comment-action="delete" data-comment-id="${item.id}">X√≥a</button>
              </div>
            </div>
          `
        )
        .join("");
      commentList.querySelectorAll("[data-comment-action]").forEach((btn) => {
        btn.addEventListener("click", async () => {
          const id = btn.dataset.commentId;
          const action = btn.dataset.commentAction;
          if (!id || !action) return;
          commentNote.textContent = "ƒêang x·ª≠ l√Ω comment...";
          const csrf = getCsrfToken();
          const res =
            action === "delete"
              ? await fetch(`/api/admin/comments/${id}`, {
                  method: "DELETE",
                  headers: { "x-csrf-token": csrf },
                })
              : await fetch(`/api/admin/comments/${id}`, {
                  method: "PUT",
                  headers: { "content-type": "application/json", "x-csrf-token": csrf },
                  body: JSON.stringify({ status: action }),
                });
          if (!res.ok) {
            commentNote.textContent = "L·ªói x·ª≠ l√Ω comment.";
            const payload = await res.json().catch(() => ({}));
            showToast(formatApiError(payload, "L·ªói x·ª≠ l√Ω comment."));
            return;
          }
          commentNote.textContent = "ƒê√£ c·∫≠p nh·∫≠t comment.";
          await loadComments();
        });
      });
    };

    newBtn?.addEventListener("click", () => {
      state.active = null;
      fillForm({});
    });

    form?.querySelector("[name='title']")?.addEventListener("input", (e) => {
      const slugInput = form.querySelector("[name='slug']");
      if (!slugInput || slugInput.value.trim()) return;
      slugInput.value = slugify(e.target.value);
      updateLinkPreview();
    });

    form?.querySelector("[name='slug']")?.addEventListener("input", updateLinkPreview);

    form?.querySelectorAll("input, textarea, select").forEach((input) => {
      input.addEventListener("input", () => {
        state.dirty = true;
        saveDraft();
      });
    });

    const requiredFields = ["title", "author", "content_md"];
    const requiredOnCreate = ["topic"];

    const savePost = async ({ silent = false } = {}) => {
      if (!form) return false;
      if (!isUnlocked()) {
        note.textContent = "C·∫ßn m·ªü kh√≥a ƒë·ªÉ l∆∞u b√†i.";
        return false;
      }
      if (!silent) note.textContent = "ƒêang l∆∞u...";
      const data = {};
      fields.forEach((name) => {
        const input = form.querySelector(`[name="${name}"]`);
        if (!input) return;
        if (name === "pinned") {
          data[name] = Number(input.value || 0);
          return;
        }
        data[name] = input.type === "number" ? Number(input.value || 0) : input.value;
      });
      const publishedAtLocal = typeof data.published_at_local === "string"
        ? data.published_at_local.trim()
        : "";
      data.published_at = toIsoFromLocalDateTime(publishedAtLocal);
      if (!data.published_at && data.status === "published") {
        data.published_at = new Date().toISOString();
      }
      data.published_tz = getDeviceTimeZone();
      delete data.published_at_local;
      if (data.tags_csv) {
        data.tags_json = JSON.stringify(
          String(data.tags_csv)
            .split(",")
            .map((t) => t.trim())
            .filter(Boolean)
        );
      }

      const isNew = !data.id;

      const missingField = requiredFields.find((name) => {
        const value = typeof data[name] === "string" ? data[name].trim() : "";
        return !value;
      });
      if (missingField) {
        const label = {
          title: "Ti√™u ƒë·ªÅ",
          author: "T√°c gi·∫£",
          content_md: "N·ªôi dung",
        }[missingField];
        note.textContent = `Thi·∫øu ${label}.`;
        const input = form.querySelector(`[name="${missingField}"]`);
        input?.focus();
        return false;
      }
      if (isNew) {
        const missingOnCreate = requiredOnCreate.find((name) => {
          const value = typeof data[name] === "string" ? data[name].trim() : "";
          return !value;
        });
        if (missingOnCreate) {
          note.textContent = "Thi·∫øu Ch·ªß ƒë·ªÅ.";
          const input = form.querySelector(`[name="${missingOnCreate}"]`);
          input?.focus();
          return false;
        }
        const contentValue = String(data.content_md || "");
        const hasImage = Boolean(data.cover_url) || /!\[.*?\]\(.+?\)/.test(contentValue);
        const hasVideo = isLikelyVideoUrl(data.video_url);
        if (!hasImage && !hasVideo) {
          note.textContent = "Thi·∫øu media. H√£y upload ·∫£nh ho·∫∑c video.";
          return false;
        }
      }
      const res = await fetch(isNew ? "/api/admin/posts" : `/api/admin/posts/${data.id}`, {
        method: isNew ? "POST" : "PUT",
        headers: { "content-type": "application/json", "x-csrf-token": getCsrfToken() },
        body: JSON.stringify(data),
      });
      const payload = await res.json().catch(() => ({}));
      if (!res.ok) {
        if (res.status === 401) {
          unlocked = false;
          setLocked(true);
          note.textContent = "C·∫ßn m·ªü kh√≥a ƒë·ªÉ l∆∞u b√†i.";
          return false;
        }
        if (!silent) {
          const message = formatApiError(payload, "L∆∞u ch∆∞a ƒë∆∞·ª£c, th·ª≠ l·∫°i nh√©.");
          note.textContent = message ? `L∆∞u l·ªói: ${message}` : "L∆∞u ch∆∞a ƒë∆∞·ª£c, th·ª≠ l·∫°i nh√©.";
          showToast(message || "L∆∞u ch∆∞a ƒë∆∞·ª£c, th·ª≠ l·∫°i nh√©.");
        }
        return false;
      }
      if (isNew) {
        data.id = payload.id;
      }
      if (payload?.slug) {
        const slugInput = form.querySelector("[name='slug']");
        if (slugInput) {
          slugInput.value = payload.slug;
        }
        updateLinkPreview();
      }
      if (!silent) note.textContent = "ƒê√£ l∆∞u.";
      clearDraft();
      await loadPosts();
      state.active = state.posts.find((p) => p.id === data.id);
      fillForm(state.active);
      return true;
    };

    form?.addEventListener("submit", async (e) => {
      e.preventDefault();
      await savePost();
    });

    setInterval(async () => {
      const id = form?.querySelector("[name='id']")?.value;
      if (!id || !state.dirty || !isUnlocked()) return;
      const saved = await savePost({ silent: true });
      if (saved) state.dirty = false;
    }, 3000);

    const buildPublishPayload = () => {
      const publishedInput = form?.querySelector("[name='published_at_local']");
      if (publishedInput && !publishedInput.value) {
        publishedInput.value = toLocalDateTimeInput(new Date());
        publishedInput.dispatchEvent(new Event("input", { bubbles: true }));
      }
      return {
        published_at: toIsoFromLocalDateTime(publishedInput?.value || "") ?? new Date().toISOString(),
        published_tz: getDeviceTimeZone(),
      };
    };

    publishBtn?.addEventListener("click", async () => {
      const id = form?.querySelector("[name='id']")?.value;
      if (!id) return;
      const res = await fetch(`/api/admin/posts/${id}/publish`, {
        method: "POST",
        headers: { "content-type": "application/json", "x-csrf-token": getCsrfToken() },
        body: JSON.stringify(buildPublishPayload()),
      });
      if (!res.ok) {
        if (res.status === 401) {
          unlocked = false;
          setLocked(true);
          note.textContent = "C·∫ßn m·ªü kh√≥a ƒë·ªÉ publish.";
          return;
        }
        const payload = await res.json().catch(() => ({}));
        const message = formatApiError(payload, "Publish l·ªói, th·ª≠ l·∫°i nh√©.");
        note.textContent = message;
        showToast(message);
        return;
      }
      await loadPosts();
      state.active = state.posts.find((p) => p.id === id);
      fillForm(state.active);
      updateLinkPreview();
      showToast("ƒê√£ publish. Link s·∫µn s√†ng m·ªü.", "success");
    });

    unpublishBtn?.addEventListener("click", async () => {
      const id = form?.querySelector("[name='id']")?.value;
      if (!id) return;
      const res = await fetch(`/api/admin/posts/${id}/unpublish`, {
        method: "POST",
        headers: { "x-csrf-token": getCsrfToken() },
      });
      if (!res.ok) {
        if (res.status === 401) {
          unlocked = false;
          setLocked(true);
          note.textContent = "C·∫ßn m·ªü kh√≥a ƒë·ªÉ g·ª° publish.";
          return;
        }
        const payload = await res.json().catch(() => ({}));
        const message = formatApiError(payload, "G·ª° publish l·ªói, th·ª≠ l·∫°i nh√©.");
        note.textContent = message;
        showToast(message);
        return;
      }
      await loadPosts();
      state.active = state.posts.find((p) => p.id === id);
      fillForm(state.active);
    });

    submitBtn?.addEventListener("click", async () => {
      const saved = await savePost();
      if (!saved) return;
      const id = form?.querySelector("[name='id']")?.value;
      if (!id) return;
      const res = await fetch(`/api/admin/posts/${id}/publish`, {
        method: "POST",
        headers: { "content-type": "application/json", "x-csrf-token": getCsrfToken() },
        body: JSON.stringify(buildPublishPayload()),
      });
      if (!res.ok) {
        if (res.status === 401) {
          unlocked = false;
          setLocked(true);
          note.textContent = "C·∫ßn m·ªü kh√≥a ƒë·ªÉ publish.";
          return;
        }
        const payload = await res.json().catch(() => ({}));
        const message = formatApiError(payload, "Publish l·ªói, th·ª≠ l·∫°i nh√©.");
        note.textContent = message;
        showToast(message);
        return;
      }
      await loadPosts();
      state.active = state.posts.find((p) => p.id === id);
      fillForm(state.active);
      note.textContent = "ƒê√£ ƒëƒÉng b√†i.";
      updateLinkPreview();
      showToast("ƒê√£ publish. Link s·∫µn s√†ng m·ªü.", "success");
    });

    deleteBtn?.addEventListener("click", async () => {
      const id = form?.querySelector("[name='id']")?.value;
      if (!id) return;
      if (!confirm("X√≥a b√†i n√†y?")) return;
      const res = await fetch(`/api/admin/posts/${id}`, {
        method: "DELETE",
        headers: { "x-csrf-token": getCsrfToken() },
      });
      if (!res.ok) {
        const payload = await res.json().catch(() => ({}));
        const message = formatApiError(payload, "X√≥a l·ªói, th·ª≠ l·∫°i nh√©.");
        note.textContent = message;
        showToast(message);
        return;
      }
      note.textContent = "ƒê√£ x√≥a.";
      await loadPosts();
      fillForm({});
    });

    previewToggle?.addEventListener("click", () => {
      if (!previewEl) return;
      previewEl.classList.toggle("hidden");
      const content = form?.querySelector("[name='content_md']")?.value ?? "";
      previewEl.innerHTML = marked.parse(content);
    });

    form?.querySelector("[name='content_md']")?.addEventListener("input", () => {
      if (!previewEl || previewEl.classList.contains("hidden")) return;
      previewEl.innerHTML = marked.parse(form.querySelector("[name='content_md']").value || "");
    });

    commentFilter?.addEventListener("change", loadComments);

    renderDeviceTimeZone();
    loadDraft();
    if (!form?.querySelector("[name='published_at_local']")?.value) {
      const publishedInput = form?.querySelector("[name='published_at_local']");
      if (publishedInput) publishedInput.value = toLocalDateTimeInput(new Date());
    }
    checkSession();

    const isHeic = (file) => {
      const name = file?.name?.toLowerCase() || "";
      return (
        file?.type === "image/heic" ||
        file?.type === "image/heif" ||
        file?.type === "image/heic-sequence" ||
        file?.type === "image/heif-sequence" ||
        name.endsWith(".heic") ||
        name.endsWith(".heif")
      );
    };

    const encodeJpeg = (canvas, quality) =>
      new Promise((resolve) => canvas.toBlob(resolve, "image/jpeg", quality));

    const decodeImage = async (source) => {
      try {
        const bitmap = await createImageBitmap(source, { imageOrientation: "from-image" });
        return {
          width: bitmap.width,
          height: bitmap.height,
          draw: (ctx, w, h) => ctx.drawImage(bitmap, 0, 0, w, h),
          cleanup: () => bitmap.close?.(),
        };
      } catch (error) {
        const url = URL.createObjectURL(source);
        const image = await new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = () => reject(new Error("IMAGE_DECODE_FAILED"));
          img.src = url;
        });
        return {
          width: image.naturalWidth || image.width,
          height: image.naturalHeight || image.height,
          draw: (ctx, w, h) => ctx.drawImage(image, 0, 0, w, h),
          cleanup: () => URL.revokeObjectURL(url),
        };
      }
    };

    const resizeImage = async (file, maxSize = 2048, quality = 0.82) => {
      const source = file;
      let decoded = null;
      try {
        decoded = await decodeImage(source);
      } catch (error) {
        throw new Error("IMAGE_DECODE_FAILED");
      }
      const ratio = Math.min(1, maxSize / Math.max(decoded.width, decoded.height));
      const targetWidth = Math.round(decoded.width * ratio);
      const targetHeight = Math.round(decoded.height * ratio);
      const canvas = document.createElement("canvas");
      canvas.width = targetWidth;
      canvas.height = targetHeight;
      const ctx = canvas.getContext("2d");
      if (!ctx) throw new Error("NO_CONTEXT");
      decoded.draw(ctx, targetWidth, targetHeight);
      decoded.cleanup?.();
      let currentQuality = quality;
      let blob = await encodeJpeg(canvas, currentQuality);
      while (blob && blob.size > MAX_FILE_BYTES && currentQuality > 0.5) {
        currentQuality = Math.max(0.5, currentQuality - 0.1);
        blob = await encodeJpeg(canvas, currentQuality);
      }
      if (!blob) throw new Error("NO_BLOB");
      return { blob, width: targetWidth, height: targetHeight };
    };

    const extensionFromMime = (type = "") => {
      if (type === "image/jpeg" || type === "image/jpg") return "jpg";
      if (type === "image/png") return "png";
      if (type === "image/webp") return "webp";
      if (type === "image/avif") return "avif";
      if (type === "image/heic" || type === "image/heic-sequence") return "heic";
      if (type === "image/heif" || type === "image/heif-sequence") return "heif";
      return "";
    };

    const renameForBlobType = (name, blobType) => {
      const ext = extensionFromMime(blobType);
      if (!ext) return name;
      const base = typeof name === "string" && name.trim() ? name.trim() : "image";
      if (/\.[a-z0-9]+$/i.test(base)) {
        return base.replace(/\.[a-z0-9]+$/i, `.${ext}`);
      }
      return `${base}.${ext}`;
    };

    const prepareUpload = async (file) => {
      if (isHeic(file)) {
        // Keep iPhone HEIC/HEIF files as-is (no auto conversion).
        return { blob: file, width: null, height: null, original: true };
      }
      try {
        const { blob, width, height } = await resizeImage(file);
        return { blob, width, height, original: false };
      } catch (error) {
        throw error;
      }
    };

    const uploadImage = async ({ file, slug, filename, sortOrder, batchId, index, signal }) => {
      const { blob, width, height, original } = await prepareUpload(file);
      const uploadName = renameForBlobType(filename || file?.name || "image", blob?.type || "");
      const formData = new FormData();
      formData.append("file", blob, uploadName);
      formData.append("slug", slug);
      formData.append(
        "meta",
        JSON.stringify({
          width,
          height,
          size: blob.size,
          originalName: file.name,
          fileName: uploadName,
          original,
          sort_order: sortOrder ?? 0,
          batch_id: batchId,
          index,
        })
      );
      const res = await fetch("/api/admin/upload", {
        method: "POST",
        headers: { "x-csrf-token": getCsrfToken() },
        body: formData,
        signal,
      });
      if (!res.ok) {
        if (res.status === 401) {
          unlocked = false;
          setLocked(true);
          throw new Error("UNAUTHORIZED");
        }
        throw new Error("UPLOAD_FAILED");
      }
      return res.json();
    };

    const requestStreamDirectUpload = async ({ file, slug, signal }) => {
      const res = await fetch("/api/admin/stream/direct-upload", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          "x-csrf-token": getCsrfToken(),
        },
        body: JSON.stringify({
          slug,
          fileName: file.name || "video.mp4",
          fileSize: file.size,
          fileType: file.type || "video/mp4",
        }),
        signal,
      });
      const payload = await res.json().catch(() => ({}));
      if (!res.ok) {
        if (res.status === 401) {
          unlocked = false;
          setLocked(true);
          throw new Error("UNAUTHORIZED");
        }
        throw new Error(formatApiError(payload, "Kh√¥ng t·∫°o ƒë∆∞·ª£c link upload Cloudflare Stream."));
      }
      return payload;
    };

    const finalizeStreamVideo = async ({ uid, signal }) => {
      const res = await fetch("/api/admin/stream/finalize", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          "x-csrf-token": getCsrfToken(),
        },
        body: JSON.stringify({ uid }),
        signal,
      });
      const payload = await res.json().catch(() => ({}));
      if (!res.ok) {
        if (res.status === 401) {
          unlocked = false;
          setLocked(true);
          throw new Error("UNAUTHORIZED");
        }
        throw new Error(formatApiError(payload, "Kh√¥ng th·ªÉ set thumbnail gi·ªØa video."));
      }
      return payload;
    };

    const uploadVideoToCloudflare = async ({ file, uploadURL, signal }) => {
      const formData = new FormData();
      formData.append("file", file, file.name || "video.mp4");

      const multipartRes = await fetch(uploadURL, {
        method: "POST",
        body: formData,
        signal,
      });
      if (multipartRes.ok) return;

      const rawRes = await fetch(uploadURL, {
        method: "PUT",
        body: file,
        signal,
      });
      if (!rawRes.ok) {
        throw new Error("STREAM_UPLOAD_FAILED");
      }
    };

    videoUploadStart?.addEventListener("click", async () => {
      if (!isUnlocked()) {
        if (videoUploadNote) videoUploadNote.textContent = "C·∫ßn m·ªü kh√≥a ƒë·ªÉ upload video.";
        return;
      }

      const file = videoUploadInput?.files?.[0];
      if (!(file instanceof File)) {
        if (videoUploadNote) videoUploadNote.textContent = "Ch·ªçn 1 video tr∆∞·ªõc khi upload.";
        return;
      }
      if (file.size <= 0) {
        if (videoUploadNote) videoUploadNote.textContent = "File video r·ªóng ho·∫∑c kh√¥ng h·ª£p l·ªá.";
        return;
      }
      if (file.size > MAX_VIDEO_FILE_BYTES) {
        if (videoUploadNote) {
          videoUploadNote.textContent =
            "File video qu√° l·ªõn (>50GB). T√°ch nh·ªè ho·∫∑c upload t·ª´ dashboard Cloudflare Stream.";
        }
        return;
      }

      const safeSlug = getSlugValue() || "untitled";
      videoUploadController?.abort();
      videoUploadController = new AbortController();
      videoUploadCancel?.classList.remove("hidden");
      if (videoUploadProgress) videoUploadProgress.textContent = "ƒêang t·∫°o link upload Cloudflare Stream...";
      if (videoUploadNote) videoUploadNote.textContent = "";

      try {
        const payload = await requestStreamDirectUpload({
          file,
          slug: safeSlug,
          signal: videoUploadController.signal,
        });
        if (!payload?.uploadURL || !payload?.uid) {
          throw new Error("Cloudflare Stream kh√¥ng tr·∫£ upload URL h·ª£p l·ªá.");
        }

        if (videoUploadProgress) videoUploadProgress.textContent = "ƒêang upload video l√™n Cloudflare Stream...";
        await uploadVideoToCloudflare({
          file,
          uploadURL: payload.uploadURL,
          signal: videoUploadController.signal,
        });

        if (videoUploadProgress) {
          videoUploadProgress.textContent =
            "ƒêang ch·ªët video (set thumbnail ·ªü ƒëo·∫°n gi·ªØa)...";
        }
        const finalized = await finalizeStreamVideo({
          uid: payload.uid,
          signal: videoUploadController.signal,
        });

        const videoUrlInput = form?.querySelector("[name='video_url']");
        const posterInput = form?.querySelector("[name='video_poster']");
        const coverInput = form?.querySelector("[name='cover_url']");
        const coverKeyInput = form?.querySelector("[name='cover_key']");
        const iframeUrl = finalized?.iframe || payload.iframe || `https://iframe.videodelivery.net/${payload.uid}`;
        const thumbnailUrl =
          finalized?.thumbnail ||
          payload.thumbnail ||
          `https://videodelivery.net/${payload.uid}/thumbnails/thumbnail.jpg`;

        if (videoUrlInput) {
          videoUrlInput.value = iframeUrl;
          videoUrlInput.dispatchEvent(new Event("input", { bubbles: true }));
        }
        if (posterInput) {
          posterInput.value = thumbnailUrl;
          posterInput.dispatchEvent(new Event("input", { bubbles: true }));
        }
        if (coverInput) {
          coverInput.value = "";
          coverInput.dispatchEvent(new Event("input", { bubbles: true }));
        }
        if (coverKeyInput) {
          coverKeyInput.value = "";
          coverKeyInput.dispatchEvent(new Event("input", { bubbles: true }));
        }

        markDirty();
        if (videoUploadNote) {
          videoUploadNote.textContent =
            "Upload xong. Thumbnail ngo√†i b√†i ƒë√£ l·∫•y t·ª± ƒë·ªông t·ª´ ƒëo·∫°n gi·ªØa video.";
        }
        showToast("ƒê√£ upload video l√™n Cloudflare Stream.", "success");
      } catch (error) {
        if (error?.name === "AbortError") {
          if (videoUploadNote) videoUploadNote.textContent = "ƒê√£ h·ªßy upload video.";
        } else if (error?.message === "STREAM_UPLOAD_FAILED") {
          if (videoUploadNote) {
            videoUploadNote.textContent =
              "Upload video th·∫•t b·∫°i. Th·ª≠ l·∫°i ho·∫∑c upload b·∫±ng Cloudflare dashboard.";
          }
          showToast("Upload video Cloudflare Stream th·∫•t b·∫°i.");
        } else {
          const message = error instanceof Error ? error.message : "Upload video th·∫•t b·∫°i.";
          if (videoUploadNote) videoUploadNote.textContent = message;
          showToast(message);
        }
      } finally {
        if (videoUploadProgress) videoUploadProgress.textContent = "";
        videoUploadCancel?.classList.add("hidden");
        videoUploadController = null;
      }
    });

    videoUploadCancel?.addEventListener("click", () => {
      videoUploadController?.abort();
      videoUploadCancel?.classList.add("hidden");
      if (videoUploadProgress) videoUploadProgress.textContent = "";
    });

    videoUploadInput?.addEventListener("change", () => {
      const file = videoUploadInput.files?.[0];
      if (!videoUploadNote) return;
      if (!(file instanceof File)) {
        videoUploadNote.textContent = "Ch∆∞a ch·ªçn video.";
        return;
      }
      const sizeMb = (file.size / (1024 * 1024)).toFixed(1);
      videoUploadNote.textContent = `ƒê√£ ch·ªçn: ${file.name} (${sizeMb} MB).`;
    });

    clearPreviewUrls = () => {
      previewUrls.forEach((url) => URL.revokeObjectURL(url));
      previewUrls = [];
    };

    renderPreview = () => {
      if (!uploadPreview) return;
      uploadPreview.innerHTML = "";
      clearPreviewUrls();
      if (!selectedFiles.length) return;
      selectedFiles.forEach((file, index) => {
        const url = URL.createObjectURL(file);
        previewUrls.push(url);
        const card = document.createElement("div");
        card.className = "compose-thumb";
        const img = document.createElement("img");
        img.src = url;
        img.alt = file.name;
        const label = document.createElement("span");
        label.textContent = index === coverIndex ? "Cover" : "·∫¢nh";
        const actions = document.createElement("div");
        actions.className = "compose-thumb__actions";
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "btn text-xs";
        btn.textContent = index === coverIndex ? "Cover" : "ƒê·∫∑t l√†m cover";
        btn.disabled = index === coverIndex;
        btn.addEventListener("click", () => {
          coverIndex = index;
          renderPreview();
        });
        actions.append(btn);
        card.append(img, label, actions);
        uploadPreview.append(card);
      });
    };

    uploadInput?.addEventListener("change", () => {
      selectedFiles = Array.from(uploadInput.files || []);
      coverIndex = 0;
      uploadBatchId = Date.now();
      renderPreview();
      markDirty();
      startUpload();
    });

    uploadCancel?.addEventListener("click", () => {
      uploadController?.abort();
      if (uploadProgress) uploadProgress.textContent = "";
      uploadCancel?.classList.add("hidden");
    });

    const startUpload = async () => {
      if (!isUnlocked()) {
        uploadNote.textContent = "C·∫ßn m·ªü kh√≥a ƒë·ªÉ upload.";
        return;
      }
      if (!selectedFiles.length) return;
      if (selectedFiles.length > MAX_UPLOAD_FILES) {
        uploadNote.textContent = `Ch·ªçn t·ªëi ƒëa ${MAX_UPLOAD_FILES} ·∫£nh th√¥i nha.`;
        return;
      }
      uploadNote.textContent = "";
      if (uploadProgress) uploadProgress.textContent = "ƒêang x·ª≠ l√Ω ·∫£nh...";
      const safeSlug = getSlugValue() || "untitled";
      const batchId = uploadBatchId ?? Date.now();
      let successCount = 0;
      uploadController?.abort();
      uploadController = new AbortController();
      uploadCancel?.classList.remove("hidden");
      let nextSortOrder = 1;
      for (const [index, file] of selectedFiles.entries()) {
        try {
          if (uploadController.signal.aborted) break;
          const filename = file.name || `image-${index + 1}.${isHeic(file) ? "heic" : "jpg"}`;
          const sortOrder = index === coverIndex ? 0 : nextSortOrder++;
          if (uploadProgress) {
            uploadProgress.textContent = `ƒêang upload ${index + 1}/${selectedFiles.length}...`;
          }
          const payload = await uploadImage({
            file,
            slug: safeSlug,
            filename,
            sortOrder,
            batchId,
            index: index + 1,
            signal: uploadController.signal,
          });
          const contentField = form?.querySelector("[name='content_md']");
          const coverInput = form?.querySelector("[name='cover_url']");
          const coverKeyInput = form?.querySelector("[name='cover_key']");
          if (sortOrder === 0) {
            if (payload.url && coverInput) {
              coverInput.value = payload.url;
              coverInput.dispatchEvent(new Event("input", { bubbles: true }));
            }
            if (payload.key && coverKeyInput) {
              coverKeyInput.value = payload.key;
              coverKeyInput.dispatchEvent(new Event("input", { bubbles: true }));
            }
            if (payload.url && contentField && !contentField.value.includes(payload.url)) {
              contentField.value = `![cover](${payload.url})\n\n${contentField.value}`.trim();
              contentField.dispatchEvent(new Event("input", { bubbles: true }));
            }
          }
          if (payload.url && contentField) {
            if (sortOrder !== 0) {
              contentField.value += `\n\n![${filename}](${payload.url})`;
              contentField.dispatchEvent(new Event("input", { bubbles: true }));
            }
            markDirty();
          }
          successCount += 1;
        } catch (error) {
          if (error?.name === "AbortError") {
            uploadNote.textContent = "ƒê√£ h·ªßy upload ·∫£nh.";
          } else if (error?.message === "IMAGE_DECODE_FAILED") {
            uploadNote.textContent = "Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c ·∫£nh n√†y ƒë·ªÉ t·ªëi ∆∞u. Vui l√≤ng th·ª≠ ·∫£nh kh√°c.";
            showToast("Image decode failed. Try another image.", "info");
          } else {
            uploadNote.textContent =
              "C√≥ ·∫£nh upload l·ªói. Th·ª≠ ·∫£nh kh√°c r·ªìi upload l·∫°i.";
          }
        }
      }
      if (uploadProgress) uploadProgress.textContent = "";
      if (!uploadController?.signal?.aborted) {
        uploadNote.textContent = `ƒê√£ upload ${successCount} ·∫£nh.`;
      }
      if (uploadInput) uploadInput.value = "";
      selectedFiles = [];
      renderPreview();
      uploadCancel?.classList.add("hidden");
      uploadController = null;
      uploadBatchId = null;
    };

    setLocked(true);
  </script>
</BaseLayout>
