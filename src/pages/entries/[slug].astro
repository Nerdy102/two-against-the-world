---
import BaseLayout from "../../layouts/BaseLayout.astro";
import RansomTitle from "../../components/RansomTitle.astro";
import FrameWall from "../../components/FrameWall.astro";
import { formatDate } from "../../lib/formatDate";
import { topicLabel, topicMeta } from "../../config/topics";
import { getDb, type PostRecord } from "../../lib/d1";
import { getHybridPostBySlug, resolvePostCoverUrl } from "../../lib/posts";
import {
  buildStreamUrls,
  extractStreamUid,
  isLikelyVideoUrl,
  normalizeVideoUrl,
} from "../../lib/stream";
import { splitSummaryFollowUp } from "../../lib/followUpLink";
import { REACTION_KINDS } from "../../lib/constants";
import { marked } from "marked";

export const prerender = false;

const slugParam = Astro.params.slug;
if (!slugParam) {
  throw new Error("Missing slug param");
}
const slug = slugParam;
let post: PostRecord | null = null;
let postMediaUrls: string[] = [];
const normalizeGallerySource = (value: string): string => {
  const trimmed = (value || "").trim();
  if (!trimmed) return "";
  const mediaMatch = trimmed.match(/^https?:\/\/[^/]+\/media\/(.+)$/i);
  if (mediaMatch?.[1]) return `/media/${mediaMatch[1]}`;
  return trimmed;
};
const sortOrderFromMeta = (metaJson: string | null | undefined) => {
  if (!metaJson) return Number.POSITIVE_INFINITY;
  try {
    const parsed = JSON.parse(metaJson);
    const sort = Number(parsed?.sort_order);
    return Number.isFinite(sort) ? sort : Number.POSITIVE_INFINITY;
  } catch {
    return Number.POSITIVE_INFINITY;
  }
};
try {
  const db = getDb(Astro.locals);
  const dbPost = await db
    .prepare(
      `SELECT *
       FROM posts
       WHERE slug = ? AND status = 'published'
       LIMIT 1`
    )
    .bind(slug)
    .first<PostRecord>();
  post = await getHybridPostBySlug(dbPost, slug);
  if (dbPost?.id) {
    try {
      const { results = [] } = await db
        .prepare(
          `SELECT url
          FROM post_media
           WHERE post_id = ?
           ORDER BY sort_order ASC, datetime(created_at) ASC`
        )
        .bind(dbPost.id)
        .all<{ url: string }>();
      postMediaUrls = (results ?? []).map((row) => normalizeGallerySource(row.url)).filter(Boolean);

      if (postMediaUrls.length <= 1) {
        const mediaLikePattern = `%posts/${slug}/%`;
        const { results: recoveredRows = [] } = await db
          .prepare(
            `SELECT url, meta_json, created_at
             FROM media
             WHERE type = 'image' AND url LIKE ?
             ORDER BY datetime(created_at) ASC`
          )
          .bind(mediaLikePattern)
          .all<{ url: string; meta_json: string | null; created_at: string | null }>();

        const recovered = (recoveredRows ?? [])
          .map((row, index) => ({
            url: normalizeGallerySource(row.url),
            sortOrder: sortOrderFromMeta(row.meta_json),
            createdAt: row.created_at ?? "",
            index,
          }))
          .filter((row) => Boolean(row.url))
          .sort((a, b) => {
            if (a.sortOrder !== b.sortOrder) return a.sortOrder - b.sortOrder;
            if (a.createdAt !== b.createdAt) return a.createdAt.localeCompare(b.createdAt);
            return a.index - b.index;
          })
          .map((row) => row.url);

        if (recovered.length > postMediaUrls.length) {
          postMediaUrls = Array.from(new Set([...postMediaUrls, ...recovered]));
        }
      }
    } catch (mediaError) {
      console.warn("post_media unavailable, fallback to photo_dir:", mediaError);
    }
  }
} catch (err) {
  console.warn("Using content post fallback:", err);
  post = await getHybridPostBySlug(null, slug);
}
if (!post) throw new Error(`Post not found: ${slug}`);
if (!String(post.cover_url ?? "").trim() && postMediaUrls.length > 0) {
  post = {
    ...post,
    cover_url: postMediaUrls[0] ?? post.cover_url,
  };
}

const rawContentMarkdown = post.body_markdown ?? post.content_md ?? "";
const turnstileSiteKey = import.meta.env.PUBLIC_TURNSTILE_SITE_KEY ?? "";
const siteUrl = import.meta.env.PUBLIC_SITE_URL ?? "";
const canonicalUrl = siteUrl ? new URL(`/entries/${post.slug}`, siteUrl).toString() : "";

// Safe helpers (avoid blank rendering)
const s = (v: unknown) => (typeof v === "string" ? v.trim() : "");
const joinTags = (tags: unknown) =>
  Array.isArray(tags) ? tags.filter(Boolean).join(", ") : "";

// Pull meta fields (your schema provides defaults, but this keeps it robust)
const summaryRaw = s(post.summary);
const { summaryText, followUpUrl, followUpLabel } = splitSummaryFollowUp(summaryRaw);
const author = s(post.author_name);
const location = s(post.location);
const eventTime = s(post.event_time);
const writtenAt = s(post.written_at);
const photoTime = s(post.photo_time);
const sideNote = s(post.side_note);
const tagsText = joinTags(
  post.tags_csv ? post.tags_csv.split(",").map((t) => t.trim()).filter(Boolean) : []
);
const voiceMemo = s(post.voice_memo);
const voiceMemoTitle = s(post.voice_memo_title);
const normalizedVideoUrl = normalizeVideoUrl(post.video_url);
const hasVideo = isLikelyVideoUrl(normalizedVideoUrl);
const videoUrl = hasVideo ? normalizedVideoUrl : "";
const videoPoster = hasVideo ? s(post.video_poster) : "";
const streamUrls = hasVideo ? buildStreamUrls(extractStreamUid(videoUrl)) : buildStreamUrls("");
const streamEmbedUrl = streamUrls.iframe
  ? (() => {
      let url: URL;
      try {
        url = new URL(streamUrls.iframe);
      } catch (_error) {
        url = new URL(streamUrls.iframe, siteUrl || "https://iframe.videodelivery.net");
      }
      url.searchParams.set("defaultTextTrack", "vi");
      return url.toString();
    })()
  : "";

const SUPPORTED_EXTENSIONS = ["jpg", "jpeg", "png", "webp", "heic", "heif"] as const;
const enableCfImageResize =
  !import.meta.env.DEV && import.meta.env.PUBLIC_ENABLE_CF_IMAGE_OPTIMIZE === "true";
const CDN_IMAGE_EXTENSIONS = new Set(SUPPORTED_EXTENSIONS);
const IMAGE_MARKDOWN_RE = /!\[[^\]]*]\(([^)\s]+)(?:\s+"[^"]*")?\)/g;
const IMAGE_HTML_RE = /<img\s+[^>]*src=["']([^"']+)["'][^>]*>/gi;

const toCloudflareResizedCandidate = (value: string): string | null => {
  if (!enableCfImageResize) return null;
  if (!value.startsWith("/")) return null;
  if (value.startsWith("/cdn-cgi/image/")) return null;
  const cleanUrl = value.split(/[?#]/)[0] ?? "";
  const ext = cleanUrl.split(".").pop()?.toLowerCase() ?? "";
  if (!CDN_IMAGE_EXTENSIONS.has(ext as (typeof SUPPORTED_EXTENSIONS)[number])) return null;
  const encodedPath = encodeURI(value.replace(/^\/+/, ""));
  return `/cdn-cgi/image/format=auto,fit=cover,width=1280,quality=78/${encodedPath}`;
};

const getImageExtension = (coverUrl: string | null | undefined) => {
  if (!coverUrl) return "jpg";
  const cleanUrl = coverUrl.split(/[?#]/)[0] ?? "";
  const ext = cleanUrl.split(".").pop()?.toLowerCase();
  if (!ext) return "jpg";
  return SUPPORTED_EXTENSIONS.includes(ext as (typeof SUPPORTED_EXTENSIONS)[number]) ? ext : "jpg";
};

const buildSrcCandidates = (src: string, ext: string) => {
  const lowerExt = ext.toLowerCase();
  const base = src.slice(0, -lowerExt.length);
  const candidates: string[] = [];
  const isHeicFamily = lowerExt === "heic" || lowerExt === "heif";

  const add = (value: string) => {
    const resized = toCloudflareResizedCandidate(value);
    if (resized) candidates.push(resized);
    candidates.push(value);
  };

  // Prefer static sidecars first so Chromium doesn't get stuck on HEIC decode failures.
  if (isHeicFamily) {
    add(`${base}jpg`);
    add(`${base}jpeg`);
    add(`${base}png`);
    add(`${base}webp`);
  }

  add(src);

  if (ext !== ext.toUpperCase()) {
    add(`${base}${ext.toUpperCase()}`);
  }

  const mediaProxyMatch = src.match(/^https?:\/\/[^/]+\/media\/(.+)$/i);
  if (mediaProxyMatch?.[1]) {
    const localMediaPath = `/media/${mediaProxyMatch[1]}`;
    add(localMediaPath);
    const localExt = localMediaPath.split(".").pop()?.toLowerCase();
    if (localExt && (localExt === "heic" || localExt === "heif")) {
      const localBase = localMediaPath.slice(0, -localExt.length);
      add(`${localBase}jpg`);
      add(`${localBase}jpeg`);
      add(`${localBase}png`);
      add(`${localBase}webp`);
    }
  }

  add("/collage/moodboard.jpg");

  return Array.from(new Set(candidates));
};

// Build photo list: /public/photos/<photoDir>/01.<extension>..N
const count = Number(post.photo_count ?? 0);
const imageExt = getImageExtension(post.cover_url);
const photosWithCandidates =
  post.photo_dir && count > 0
    ? Array.from({ length: Math.max(0, count) }, (_, i) => {
        const n = String(i + 1).padStart(2, "0");
        const src = `/photos/${post.photo_dir}/${n}.${imageExt}`;
        return {
          src,
          candidates: buildSrcCandidates(src, imageExt),
        };
      })
    : [];

const coverSrc = resolvePostCoverUrl(post);
const coverExt = getImageExtension(post.cover_url);

const dedupeOrderedSources = (sources: string[]) => {
  const ordered: string[] = [];
  const seen = new Set<string>();
  for (const source of sources) {
    const normalized = normalizeGallerySource(source);
    if (!normalized || seen.has(normalized)) continue;
    seen.add(normalized);
    ordered.push(normalized);
  }
  return ordered;
};

const extractImageUrlsFromMarkdown = (markdown: string | null | undefined) => {
  if (!markdown) return [];
  IMAGE_MARKDOWN_RE.lastIndex = 0;
  IMAGE_HTML_RE.lastIndex = 0;
  const urls: string[] = [];
  const add = (value: string) => {
    const raw = (value ?? "").trim().replace(/^<|>$/g, "");
    if (!raw || urls.includes(raw)) return;
    urls.push(raw);
  };
  for (;;) {
    const match = IMAGE_MARKDOWN_RE.exec(markdown);
    if (!match) break;
    add(match[1] ?? "");
  }
  for (;;) {
    const match = IMAGE_HTML_RE.exec(markdown);
    if (!match) break;
    add(match[1] ?? "");
  }
  return urls;
};

const markdownGallerySources = [
  ...extractImageUrlsFromMarkdown(post.body_markdown),
  ...extractImageUrlsFromMarkdown(post.content_md),
];

const fallbackPhotoSources = photosWithCandidates.map((photo) => photo.src);

const orderedGallerySources = dedupeOrderedSources(
  [coverSrc, ...postMediaUrls, ...markdownGallerySources, ...fallbackPhotoSources]
);

const stripGalleryImagesFromMarkdown = (markdown: string, gallerySources: string[]) => {
  const normalizedGallery = new Set(gallerySources.map((source) => normalizeGallerySource(source)).filter(Boolean));
  if (!normalizedGallery.size) return markdown;

  const withoutMarkdownImages = markdown.replace(
    /!\[[^\]]*]\(([^)\s]+)(?:\s+"[^"]*")?\)\s*/g,
    (fullMatch, src) => {
      const normalized = normalizeGallerySource(String(src ?? "").trim().replace(/^<|>$/g, ""));
      return normalizedGallery.has(normalized) ? "" : fullMatch;
    }
  );

  const withoutHtmlImages = withoutMarkdownImages.replace(
    /<img\s+[^>]*src=["']([^"']+)["'][^>]*>\s*/gi,
    (fullMatch, src) => {
      const normalized = normalizeGallerySource(String(src ?? "").trim().replace(/^<|>$/g, ""));
      return normalizedGallery.has(normalized) ? "" : fullMatch;
    }
  );

  return withoutHtmlImages.replace(/\n{3,}/g, "\n\n").trim();
};

const contentHtml = marked.parse(stripGalleryImagesFromMarkdown(rawContentMarkdown, orderedGallerySources));

const wallImages = orderedGallerySources.map((src, index) => ({
  src,
  alt: index === 0 ? `${post.title} ‚Äî cover` : `${post.title} ‚Äî photo ${index}`,
  candidates: buildSrcCandidates(src, index === 0 ? coverExt : getImageExtension(src)),
}));
const wallPhotoCount = Math.max(0, wallImages.length - 1);
---

<BaseLayout title={post.title} description={summaryText}>
  <main class="mx-auto max-w-5xl px-4 sm:px-6 lg:px-8 py-10">
    {/* TOP PAPER (TITLE + META) */}
    <div class="paper edge-torn p-6 sm:p-10 entry-hero" data-reveal>
      <div class="kicker text-xs text-[rgba(0,0,0,0.58)]">Emotional Anchor</div>

      <RansomTitle text={post.title} as="h1" stampEvery={0} class="mt-3 entry-title" />

      {(summaryText || followUpUrl || author) && (
        <div class="mt-4 max-w-2xl entry-summary">
          {summaryText && <p class="entry-summary__desc">{summaryText}</p>}
          {followUpUrl && (
            <a
              class="entry-summary__follow-link"
              href={followUpUrl}
              target="_blank"
              rel="noopener noreferrer"
            >
              {followUpLabel || "Link"} ‚Üó
            </a>
          )}
          {author && <span class="entry-summary__author">‚Äî {author}</span>}
        </div>
      )}

      <div class="entry-meta mt-5 flex flex-wrap items-center gap-3 text-[12px] text-black/60">
        <span>Ch·ªß ƒë·ªÅ: {topicLabel(post.topic ?? undefined)}</span>
        <span>‚Ä¢</span>
        <span>{formatDate(post.published_at ?? post.created_at, { includeTime: true, timeZone: post.published_tz ?? undefined })}</span>
      </div>

      <div class="entry-share">
        <button
          class="share-btn share-btn--hero"
          type="button"
          data-share-link
          data-share-url={canonicalUrl}
          aria-label="Chia s·∫ª b√†i vi·∫øt"
          title="Chia s·∫ª"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path
              d="M21.8 3.2L10.2 12.7"
              fill="none"
              stroke="currentColor"
              stroke-width="1.8"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
            <path
              d="M21.8 3.2l-5.9 17.4-3.2-6.1-6.9-2.1 16-9.2z"
              fill="none"
              stroke="currentColor"
              stroke-width="1.8"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
          <span class="share-btn__label">SHARE</span>
        </button>
        <span class="share-toast" data-share-state role="status" aria-live="polite" aria-atomic="true"></span>
      </div>
    </div>

    {/* PHOTO WALL */}
    {!hasVideo && (
      <section class="mt-10" aria-label="B·ª©c t∆∞·ªùng ·∫£nh">
        <FrameWall images={wallImages} seed={post.slug} />
      </section>
    )}

    {/* MEDIA */}
    {(voiceMemo || hasVideo) && (
      <section
        class={`mt-10 media-section ${hasVideo ? "media-section--video" : ""}`}
        aria-label="ƒêa ph∆∞∆°ng ti·ªán"
        data-reveal
        id={hasVideo ? "entry-video" : undefined}
      >
        <div class={`paper edge-torn p-6 sm:p-10 media-paper ${hasVideo ? "media-paper--video" : ""}`}>
          <div class="kicker text-xs media-kicker">Embracing the uncertainties of life</div>
          <h2 class="mt-3 text-[26px] sm:text-[32px] font-semibold media-title">
            Xem v√† Khen <span class="media-title-icon" aria-hidden="true">üòà</span>
          </h2>

          {hasVideo && (
            <div class="mt-4 video-punk-wrap">
              <div class="meta-label media-meta-label">Video</div>
              {streamEmbedUrl ? (
                <div class="video-punk-frame mt-2" style="aspect-ratio: 16 / 9;">
                  <iframe
                    class="h-full w-full"
                    src={streamEmbedUrl}
                    data-video-stream-iframe
                    data-video-base-src={streamUrls.iframe}
                    title={`${post.title} video`}
                    loading="lazy"
                    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture; fullscreen"
                    allowfullscreen
                  ></iframe>
                </div>
              ) : (
                <div class="video-punk-frame mt-2" style="aspect-ratio: 16 / 9;">
                  <video
                    class="h-full w-full bg-black object-contain"
                    controls
                    preload="metadata"
                    playsinline
                    poster={videoPoster || undefined}
                    data-video-native
                    src={videoUrl}
                  ></video>
                </div>
              )}
              <div class="video-controls mt-3" data-video-controls data-open="0">
                <button
                  class="video-controls__toggle"
                  type="button"
                  data-video-controls-toggle
                  aria-label="M·ªü c√†i ƒë·∫∑t video"
                  aria-expanded="false"
                  aria-controls="video-controls-panel"
                  title="C√†i ƒë·∫∑t video"
                >
                  <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                    <path
                      d="M19.4 13.5a7.9 7.9 0 0 0 .1-1.5 7.9 7.9 0 0 0-.1-1.5l2-1.6a.5.5 0 0 0 .1-.6l-1.9-3.2a.5.5 0 0 0-.6-.2l-2.4 1a8 8 0 0 0-2.6-1.5l-.4-2.6a.5.5 0 0 0-.5-.4h-3.8a.5.5 0 0 0-.5.4l-.4 2.6a8 8 0 0 0-2.6 1.5l-2.4-1a.5.5 0 0 0-.6.2L2.5 8.3a.5.5 0 0 0 .1.6l2 1.6a7.9 7.9 0 0 0-.1 1.5 7.9 7.9 0 0 0 .1 1.5l-2 1.6a.5.5 0 0 0-.1.6l1.9 3.2a.5.5 0 0 0 .6.2l2.4-1a8 8 0 0 0 2.6 1.5l.4 2.6a.5.5 0 0 0 .5.4h3.8a.5.5 0 0 0 .5-.4l.4-2.6a8 8 0 0 0 2.6-1.5l2.4 1a.5.5 0 0 0 .6-.2l1.9-3.2a.5.5 0 0 0-.1-.6z"
                      fill="none"
                      stroke="currentColor"
                      stroke-width="1.3"
                      stroke-linecap="round"
                      stroke-linejoin="round"
                    />
                    <circle
                      cx="12"
                      cy="12"
                      r="2.9"
                      fill="none"
                      stroke="currentColor"
                      stroke-width="1.3"
                    />
                  </svg>
                </button>
                <div class="video-controls__panel" data-video-controls-panel id="video-controls-panel">
                  <div class="video-quality" data-video-quality>
                    <span class="video-quality__label">ƒê·ªô ph√¢n gi·∫£i</span>
                    <div class="video-quality__options" role="group" aria-label="Ch·ªçn ƒë·ªô ph√¢n gi·∫£i video">
                      <button class="video-quality__btn is-active" type="button" data-video-quality-mode="auto">Auto</button>
                      <button class="video-quality__btn" type="button" data-video-quality-mode="sd">SD</button>
                      <button class="video-quality__btn" type="button" data-video-quality-mode="hd">HD</button>
                    </div>
                  </div>
                  <div class="video-captions" data-video-captions>
                    <span class="video-captions__label">Ph·ª• ƒë·ªÅ</span>
                    <div class="video-captions__options" role="group" aria-label="Ch·ªçn ph·ª• ƒë·ªÅ video">
                      <button class="video-captions__btn is-active" type="button" data-video-caption-mode="vi">VI</button>
                      <button class="video-captions__btn" type="button" data-video-caption-mode="en">EN</button>
                      <button class="video-captions__btn" type="button" data-video-caption-mode="off">Off</button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}

          {voiceMemo && (
            <div class="mt-4">
              <div class="meta-label media-meta-label">Ghi √¢m</div>
              {voiceMemoTitle && <div class="mt-1 media-voice-title">{voiceMemoTitle}</div>}
              <audio class="mt-2 w-full media-audio" controls src={voiceMemo}></audio>
            </div>
          )}
        </div>
      </section>
    )}

    {/* NOTES / BODY */}
    <section class="mt-10" aria-label="Ghi ch√∫" data-reveal>
      <div class="paper edge-torn p-6 sm:p-10 prose prose-scrap max-w-none">
        <div set:html={contentHtml} />
      </div>
    </section>

    {/* COMMENTS */}
    <section class="mt-10" aria-label="B√¨nh lu·∫≠n" data-reveal>
      <div class="paper paper--alt edge-torn p-6 sm:p-10 comment-slab">
        <div class="kicker text-xs text-black/50">üí¨</div>
        <h2 class="mt-3 text-[26px] sm:text-[32px] font-semibold text-black/80">ƒê·ªÉ l·∫°i l·ªùi nh·∫Øn x√†m x√≠</h2>
        <div class="comment-intro-row mt-2">
          <p class="comment-helper text-black/60">Nh·∫≠p bi·ªát danh r·ªìi th·∫£ v√†i d√≤ng nha.</p>
          <div class="comment-share-wrap">
            <button
              class="comment-share-btn"
              type="button"
              data-comment-share-link
              data-share-url={canonicalUrl}
              aria-label="Share / Copy link"
              title="Share / Copy link"
            >
              <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <path
                  d="M21.8 3.2L10.2 12.7"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="1.6"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                <path
                  d="M21.8 3.2l-5.9 17.4-3.2-6.1-6.9-2.1 16-9.2z"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="1.6"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
              </svg>
            </button>
            <span
              class="share-toast comment-share-toast"
              data-comment-share-state
              role="status"
              aria-live="polite"
              aria-atomic="true"
            ></span>
          </div>
        </div>

        <div class="mt-4 flex flex-wrap items-center gap-3">
          <div class="reaction-bar" data-reaction-bar>
            {REACTION_KINDS.map((kind) => (
              <button class="btn reaction-btn" type="button" data-reaction-kind={kind}>
                {kind} <span data-reaction-count>0</span>
              </button>
            ))}
          </div>
          <span class="text-xs text-black/50" data-reaction-state>Ch·ªçn icon ƒë·ªÉ th·∫£ c·∫£m x√∫c.</span>
          <div class="comment-toast reaction-toast" data-reaction-toast role="status" aria-live="polite" aria-atomic="true"></div>
        </div>

        <form class="comment-form mt-6" data-comment-form data-comment-slug={post.slug}>
          <label class="comment-field">
            <span>Bi·ªát danh</span>
            <input class="input" name="nickname" placeholder="Bi·ªát danh (·∫©n danh)" maxlength="40" required />
          </label>
          <label class="comment-field comment-field--full">
            <span>N·ªôi dung</span>
            <textarea class="input comment-textarea" name="message" rows={4} placeholder="Vi·∫øt g√¨ ƒë√≥..." maxlength="2000" required></textarea>
          </label>
          <button class="btn comment-submit" type="submit">G·ª≠i l·ªùi nh·∫Øn</button>
          <p class="comment-hint" data-comment-error></p>
          <div class="comment-toast" data-comment-toast role="status" aria-live="polite" aria-atomic="true"></div>
        </form>

        {turnstileSiteKey && (
          <div class="mt-4">
            <div
              class="cf-turnstile"
              data-sitekey={turnstileSiteKey}
              data-theme="light"
              data-size="flexible"
              data-appearance="interaction-only"
              data-turnstile-widget
            ></div>
          </div>
        )}

        <div class="comment-list mt-8" data-comment-list></div>
      </div>
    </section>

    {/* META GRID */}
    <section class="mt-10" aria-label="Chi ti·∫øt b√†i vi·∫øt" data-reveal>
      <div class="paper paper--alt edge-torn p-6 sm:p-10 entry-meta-wrap">
        <div class="kicker text-xs text-black/50">CHUY·ªÜN L·∫ÆT NH·∫ÆT ‚ú®</div>
        <h2 class="mt-3 text-[26px] sm:text-[32px] font-semibold text-black/80">Chuy·ªán nh·ªè x√≠u ‚ú®</h2>

        <div class="mt-6 grid grid-cols-1 sm:grid-cols-3 gap-3">
          <div class="meta-card">
            <div class="meta-k">Ng√†y ƒëƒÉng</div>
            <div class="meta-v">{formatDate(post.published_at ?? post.created_at, { includeTime: true, timeZone: post.published_tz ?? undefined })}</div>
          </div>

          <div class="meta-card">
            <div class="meta-k">Ch·ªß ƒë·ªÅ</div>
            <div class="meta-v">
              <span style={`color:${topicMeta(post.topic ?? undefined).color};`}>
                {topicLabel(post.topic ?? undefined)}
              </span>
            </div>
          </div>

          <div class="meta-card">
            <div class="meta-k">S·ªë ·∫£nh</div>
            <div class="meta-v">{wallPhotoCount}</div>
          </div>

          <div class="meta-card">
            <div class="meta-k">T√°c gi·∫£</div>
            <div class="meta-v">{author || "‚Äî"}</div>
          </div>

          <div class="meta-card">
            <div class="meta-k">ƒê·ªãa ƒëi·ªÉm</div>
            <div class="meta-v">{location || "‚Äî"}</div>
          </div>

          <div class="meta-card">
            <div class="meta-k">Th·ªùi gian s·ª± ki·ªán</div>
            <div class="meta-v">{eventTime || "‚Äî"}</div>
          </div>

          <div class="meta-card">
            <div class="meta-k">Vi·∫øt l√∫c</div>
            <div class="meta-v">{writtenAt || "‚Äî"}</div>
          </div>

          <div class="meta-card">
            <div class="meta-k">Ch·ª•p l√∫c</div>
            <div class="meta-v">{photoTime || "‚Äî"}</div>
          </div>

          <div class="meta-card">
            <div class="meta-k">Tags</div>
            <div class="meta-v">{tagsText || "‚Äî"}</div>
          </div>
        </div>

        {sideNote && (
          <div class="mt-6 meta-card">
            <div class="meta-k">Ghi ch√∫ th√™m</div>
            <div class="meta-v">{sideNote}</div>
          </div>
        )}
      </div>
    </section>
  </main>

  <script is:inline>
    const initComments = () => {
      const form = document.querySelector("[data-comment-form]");
      const list = document.querySelector("[data-comment-list]");
      const err = document.querySelector("[data-comment-error]");
      const toast = document.querySelector("[data-comment-toast]");
      const hasTurnstile = Boolean(document.querySelector("[data-turnstile-widget]"));

      if (!form || !list) return;
      if (form.dataset.bound === "1") return;
      form.dataset.bound = "1";

      const slug = form.dataset.commentSlug || "unknown";
      const escapeHtml = (value = "") =>
        String(value)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      const parseCommentDate = (value) => {
        if (typeof value !== "string") return null;
        const raw = value.trim();
        if (!raw) return null;
        let normalized = raw;
        if (/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/.test(raw)) {
          normalized = `${raw.replace(" ", "T")}Z`;
        } else if (
          /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?$/.test(raw)
        ) {
          normalized = `${raw}Z`;
        }
        const parsed = new Date(normalized);
        return Number.isNaN(parsed.getTime()) ? null : parsed;
      };
      const formatOffset = (minutesEast) => {
        if (!Number.isFinite(minutesEast)) return "";
        const sign = minutesEast >= 0 ? "+" : "-";
        const abs = Math.abs(Math.trunc(minutesEast));
        const hh = String(Math.floor(abs / 60)).padStart(2, "0");
        const mm = String(abs % 60).padStart(2, "0");
        return `${sign}${hh}:${mm}`;
      };
      const getPostedZoneLabel = (timeZone) => {
        const tz = typeof timeZone === "string" ? timeZone.trim() : "";
        if (tz === "Asia/Ho_Chi_Minh" || tz === "Asia/Saigon") return "üáªüá≥ Gi·ªù Vi·ªát";
        if (tz === "Asia/Tokyo") return "üáØüáµ Gi·ªù Nh·∫≠t";
        if (tz.startsWith("America/") || tz === "Pacific/Honolulu") return "üá∫üá∏ Gi·ªù M·ªπ";
        return "";
      };
      const formatCommentTime = (item = {}) => {
        const clientLocal = parseCommentDate(item.client_local_at);
        const tz = typeof item.client_time_zone === "string" ? item.client_time_zone.trim() : "";
        if (clientLocal) {
          const text = tz
            ? clientLocal.toLocaleString("vi-VN", { timeZone: tz })
            : clientLocal.toLocaleString("vi-VN");
          const label = getPostedZoneLabel(tz);
          return label ? `${text} (${label})` : text;
        }
        const createdAt = parseCommentDate(item.created_at);
        return createdAt ? createdAt.toLocaleString("vi-VN") : "‚Äî";
      };
      const buildClientLocalIso = (date) => {
        const pad = (value) => String(value).padStart(2, "0");
        const year = date.getFullYear();
        const month = pad(date.getMonth() + 1);
        const day = pad(date.getDate());
        const hours = pad(date.getHours());
        const minutes = pad(date.getMinutes());
        const seconds = pad(date.getSeconds());
        const offsetMinutes = -date.getTimezoneOffset();
        const offset = formatOffset(offsetMinutes);
        return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}${offset}`;
      };
      const render = (items = []) => {
        if (!items.length) {
          list.innerHTML = "<p class='text-black/60 text-sm'>Ch∆∞a c√≥ l·ªùi nh·∫Øn n√†o.</p>";
          return;
        }
        list.innerHTML = items
          .map(
            (item) => `
              <div class="comment-card">
                <div class="comment-meta">
                  <span class="comment-name">${escapeHtml(item.display_name || "·∫®n danh")}</span>
                  <span class="comment-time">${escapeHtml(formatCommentTime(item))}</span>
                </div>
                <p class="comment-body">${escapeHtml(item.body)}</p>
              </div>
            `
          )
          .join("");
      };

      const formatApiError = (payload, fallback) => {
        const message = [payload?.error, payload?.detail].filter(Boolean).join(" ‚Äî ");
        return message || fallback;
      };

      let toastTimeout = null;
      const showToast = (message, variant = "error") => {
        if (!toast) return;
        toast.textContent = message;
        toast.dataset.state = variant;
        toast.classList.add("is-visible");
        if (toastTimeout) window.clearTimeout(toastTimeout);
        toastTimeout = window.setTimeout(() => {
          toast.classList.remove("is-visible");
          toast.textContent = "";
          toast.dataset.state = "";
        }, 2200);
      };

      const refresh = async () => {
        try {
          const res = await fetch(`/api/comments?slug=${encodeURIComponent(slug)}`);
          if (!res.ok) {
            const payload = await res.json().catch(() => ({}));
            const message = formatApiError(payload, "Ch∆∞a t·∫£i ƒë∆∞·ª£c l·ªùi nh·∫Øn.");
            if (err) err.textContent = message;
            showToast(message);
            return;
          }
          const data = await res.json();
          render(data.comments || []);
        } catch (error) {
          if (err) err.textContent = "Ch∆∞a t·∫£i ƒë∆∞·ª£c l·ªùi nh·∫Øn.";
        }
      };

      refresh();
      const poll = setInterval(refresh, 5000);

      form.addEventListener("submit", (e) => {
        e.preventDefault();
        const nickname = form.querySelector("input[name='nickname']")?.value?.trim();
        const message = form.querySelector("textarea[name='message']")?.value?.trim();
        if (!nickname || !message) {
          if (err) err.textContent = "Nh·∫≠p bi·ªát danh + l·ªùi nh·∫Øn m·ªõi ƒë∆∞·ª£c nh√©!";
          showToast("Nh·∫≠p bi·ªát danh + l·ªùi nh·∫Øn m·ªõi ƒë∆∞·ª£c nh√©!");
          return;
        }
        const now = new Date();
        const clientTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone || null;
        const clientOffsetMinutes = -now.getTimezoneOffset();
        const clientLocalAt = buildClientLocalIso(now);
        fetch("/api/comments", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({
            slug,
            displayName: nickname,
            body: message,
            clientTimeZone,
            clientOffsetMinutes,
            clientLocalAt,
            turnstileToken: hasTurnstile && window.turnstile ? window.turnstile.getResponse() : null,
          }),
        })
          .then(async (res) => {
            const data = await res.json().catch(() => ({}));
            if (!res.ok) {
              const messageText = formatApiError(data, "G·ª≠i ch∆∞a ƒë∆∞·ª£c, th·ª≠ l·∫°i sau nha.");
              if (err) err.textContent = messageText;
              showToast(messageText);
              return;
            }
            form.reset();
            if (err) {
              err.textContent = "";
            }
            showToast("ƒê√£ g·ª≠i l·ªùi nh·∫Øn.", "success");
            if (hasTurnstile && window.turnstile) {
              window.turnstile.reset();
            }
            refresh();
          })
          .catch(() => {
            const messageText = "G·ª≠i ch∆∞a ƒë∆∞·ª£c, th·ª≠ l·∫°i sau nha.";
            if (err) err.textContent = messageText;
            showToast(messageText);
          });
      });

      document.addEventListener("astro:before-swap", () => clearInterval(poll), { once: true });
    };

    initComments();
    document.addEventListener("astro:page-load", initComments);
  </script>

  {turnstileSiteKey && (
    <script is:inline src="https://challenges.cloudflare.com/turnstile/v0/api.js" async defer></script>
  )}

  <script is:inline>
    const initVideoControls = () => {
      const controls = document.querySelector("[data-video-controls]");
      if (!(controls instanceof HTMLElement)) return;
      if (controls.dataset.bound === "1") return;
      controls.dataset.bound = "1";

      const panel = controls.querySelector("[data-video-quality]");
      const captions = controls.querySelector("[data-video-captions]");
      const iframe = document.querySelector("[data-video-stream-iframe]");
      const nativeVideo = document.querySelector("[data-video-native]");
      if (!(panel instanceof HTMLElement)) return;
      if (!(iframe instanceof HTMLIFrameElement) && !(nativeVideo instanceof HTMLVideoElement)) return;
      const panelEl = controls.querySelector("[data-video-controls-panel]");
      const toggle = controls.querySelector("[data-video-controls-toggle]");

      const qualityButtons = Array.from(panel.querySelectorAll("[data-video-quality-mode]"));
      const captionButtons = captions instanceof HTMLElement
        ? Array.from(captions.querySelectorAll("[data-video-caption-mode]"))
        : [];
      if (!qualityButtons.length) return;

      const setOpen = (open) => {
        controls.dataset.open = open ? "1" : "0";
        if (toggle instanceof HTMLButtonElement) {
          toggle.setAttribute("aria-expanded", open ? "true" : "false");
        }
      };
      const closeOnMobile = () => {
        if (window.matchMedia("(max-width: 640px)").matches) {
          setOpen(false);
        }
      };

      if (toggle instanceof HTMLButtonElement && panelEl instanceof HTMLElement) {
        toggle.addEventListener("click", (event) => {
          event.preventDefault();
          setOpen(controls.dataset.open !== "1");
        });
      }

      setOpen(false);

      const setActiveQuality = (mode) => {
        qualityButtons.forEach((button) => {
          button.classList.toggle("is-active", button.dataset.videoQualityMode === mode);
        });
      };
      const setActiveCaption = (mode) => {
        captionButtons.forEach((button) => {
          button.classList.toggle("is-active", button.dataset.videoCaptionMode === mode);
        });
      };

      if (iframe instanceof HTMLIFrameElement) {
        const baseSrc = iframe.getAttribute("data-video-base-src") || iframe.getAttribute("src") || "";
        if (!baseSrc) return;
        const bandwidthHintByMode = {
          auto: "",
          sd: "2.4",
          hd: "8",
        };
        let selectedQualityMode = "auto";
        let selectedCaptionMode = "vi";

        const buildIframeSrc = (qualityMode, captionMode) => {
          let url;
          try {
            url = new URL(baseSrc);
          } catch (_error) {
            url = new URL(baseSrc, window.location.origin);
          }
          const hint = bandwidthHintByMode[qualityMode] || "";
          if (hint) {
            url.searchParams.set("clientBandwidthHint", hint);
          } else {
            url.searchParams.delete("clientBandwidthHint");
          }
          if (captionMode === "off") {
            url.searchParams.delete("defaultTextTrack");
          } else {
            url.searchParams.set("defaultTextTrack", captionMode);
          }
          return url.toString();
        };

        const applyModes = () => {
          const nextSrc = buildIframeSrc(selectedQualityMode, selectedCaptionMode);
          if (iframe.src !== nextSrc) iframe.src = nextSrc;
          setActiveQuality(selectedQualityMode);
          setActiveCaption(selectedCaptionMode);
        };

        qualityButtons.forEach((button) => {
          button.addEventListener("click", (event) => {
            event.preventDefault();
            const mode = button.dataset.videoQualityMode;
            if (mode !== "sd" && mode !== "hd") {
              selectedQualityMode = "auto";
            } else {
              selectedQualityMode = mode;
            }
            applyModes();
            closeOnMobile();
          });
        });

        captionButtons.forEach((button) => {
          button.addEventListener("click", (event) => {
            event.preventDefault();
            const mode = button.dataset.videoCaptionMode;
            if (mode !== "en" && mode !== "off") {
              selectedCaptionMode = "vi";
            } else {
              selectedCaptionMode = mode;
            }
            applyModes();
            closeOnMobile();
          });
        });

        applyModes();
        return;
      }

      if (!(nativeVideo instanceof HTMLVideoElement)) return;
      const baseVideoSrc = nativeVideo.getAttribute("src") || nativeVideo.currentSrc || "";
      const sdButton = qualityButtons.find((button) => button.dataset.videoQualityMode === "sd");
      if (sdButton) {
        sdButton.disabled = true;
        sdButton.title = "Video n√†y ch∆∞a c√≥ b·∫£n SD ri√™ng";
      }

      let selectedQualityMode = "hd";
      const getTrackList = () =>
        Array.from(nativeVideo.textTracks || []);

      const applyNativeCaption = (mode) => {
        const tracks = getTrackList();
        if (!tracks.length) {
          captionButtons.forEach((button) => {
            button.disabled = true;
            button.title = "Video n√†y ch∆∞a c√≥ ph·ª• ƒë·ªÅ";
          });
          setActiveCaption("off");
          return "off";
        }
        captionButtons.forEach((button) => {
          button.disabled = false;
          button.title = "";
        });
        tracks.forEach((track) => {
          track.mode = "disabled";
        });
        if (mode === "off") {
          setActiveCaption("off");
          return "off";
        }
        const target = tracks.find((track) =>
          String(track.language || "").toLowerCase().startsWith(mode)
        );
        if (!target) {
          setActiveCaption("off");
          return "off";
        }
        target.mode = "showing";
        setActiveCaption(mode);
        return mode;
      };

      qualityButtons.forEach((button) => {
        button.addEventListener("click", (event) => {
          event.preventDefault();
          const mode = button.dataset.videoQualityMode;
          if (mode === "hd" && baseVideoSrc) {
            if (nativeVideo.getAttribute("src") !== baseVideoSrc) {
              nativeVideo.setAttribute("src", baseVideoSrc);
              nativeVideo.load();
            }
            selectedQualityMode = "hd";
          } else if (mode !== "sd") {
            selectedQualityMode = "auto";
          }
          setActiveQuality(selectedQualityMode);
          closeOnMobile();
        });
      });

      let selectedCaptionMode = "vi";
      captionButtons.forEach((button) => {
        button.addEventListener("click", (event) => {
          event.preventDefault();
          const mode = button.dataset.videoCaptionMode;
          if (mode === "en" || mode === "off" || mode === "vi") {
            selectedCaptionMode = applyNativeCaption(mode);
          } else {
            selectedCaptionMode = applyNativeCaption("vi");
          }
          closeOnMobile();
        });
      });

      nativeVideo.addEventListener("loadedmetadata", () => {
        applyNativeCaption(selectedCaptionMode);
      });

      setActiveQuality(selectedQualityMode);
      selectedCaptionMode = applyNativeCaption("vi");
    };

    initVideoControls();
    document.addEventListener("astro:page-load", initVideoControls);
  </script>

  <script is:inline>
    const initReactions = () => {
      const bar = document.querySelector("[data-reaction-bar]");
      const stateEl = document.querySelector("[data-reaction-state]");
      const toast = document.querySelector("[data-reaction-toast]");
      const shareBtn = document.querySelector("[data-share-link]");
      const shareState = document.querySelector("[data-share-state]");
      const commentShareBtn = document.querySelector("[data-comment-share-link]");
      const commentShareState = document.querySelector("[data-comment-share-state]");
      const form = document.querySelector("[data-comment-form]");
      if (!bar || !form) return;
      if (bar.dataset.bound === "1") return;
      bar.dataset.bound = "1";

      const buttons = Array.from(bar.querySelectorAll("[data-reaction-kind]"));
      const slug = form.dataset.commentSlug || "unknown";

      const formatApiError = (payload, fallback) => {
        const message = [payload?.error, payload?.detail].filter(Boolean).join(" ‚Äî ");
        return message || fallback;
      };

      let toastTimeout = null;
      const showToast = (message, variant = "success") => {
        if (!toast) return;
        toast.textContent = message;
        toast.dataset.state = variant;
        toast.classList.add("is-visible");
        if (toastTimeout) window.clearTimeout(toastTimeout);
        toastTimeout = window.setTimeout(() => {
          toast.classList.remove("is-visible");
          toast.textContent = "";
          toast.dataset.state = "";
        }, 2200);
      };

      const showReactionError = (message) => {
        if (stateEl) stateEl.textContent = message;
        showToast(message, "error");
      };

      const render = ({ counts = {}, total = 0 }) => {
        buttons.forEach((button) => {
          const kind = button.dataset.reactionKind;
          if (!kind) return;
          const countEl = button.querySelector("[data-reaction-count]");
          const count = Number(counts[kind] ?? 0);
          if (countEl) countEl.textContent = count;
        });
        if (stateEl) {
          stateEl.textContent = total
            ? `ƒê√£ th·∫£ ${total} c·∫£m x√∫c.`
            : "Ch·ªçn icon ƒë·ªÉ th·∫£ c·∫£m x√∫c.";
        }
      };

      const load = async () => {
        const res = await fetch(`/api/reactions?slug=${encodeURIComponent(slug)}`);
        if (!res.ok) {
          const payload = await res.json().catch(() => ({}));
          showReactionError(formatApiError(payload, "Ch∆∞a t·∫£i ƒë∆∞·ª£c c·∫£m x√∫c."));
          return;
        }
        const data = await res.json();
        render(data);
      };

      buttons.forEach((button) => {
        button.addEventListener("click", async () => {
          const kind = button.dataset.reactionKind;
          if (!kind) return;
          const res = await fetch("/api/reactions", {
            method: "POST",
            headers: { "content-type": "application/json" },
            body: JSON.stringify({ slug, kind }),
          });
          if (!res.ok) {
            const payload = await res.json().catch(() => ({}));
            showReactionError(formatApiError(payload, "Ch∆∞a g·ª≠i ƒë∆∞·ª£c c·∫£m x√∫c."));
            return;
          }
          const data = await res.json();
          render(data);
          showToast("ƒê√£ c·∫≠p nh·∫≠t c·∫£m x√∫c.", "success");
        });
      });

      const shareTimeouts = new Map();
      const showShareToast = (stateEl, message, variant = "success") => {
        if (!stateEl) return;
        stateEl.textContent = message;
        stateEl.dataset.state = variant;
        stateEl.classList.add("is-visible");
        const existing = shareTimeouts.get(stateEl);
        if (existing) window.clearTimeout(existing);
        const timeout = window.setTimeout(() => {
          stateEl.classList.remove("is-visible");
          stateEl.textContent = "";
          stateEl.dataset.state = "";
        }, 2000);
        shareTimeouts.set(stateEl, timeout);
      };

      const fallbackCopy = (text) => {
        const textarea = document.createElement("textarea");
        textarea.value = text;
        textarea.setAttribute("readonly", "");
        textarea.style.position = "absolute";
        textarea.style.left = "-9999px";
        document.body.appendChild(textarea);
        textarea.select();
        const ok = document.execCommand("copy");
        document.body.removeChild(textarea);
        return ok;
      };

      const bindShareButton = (button, stateEl) => {
        if (!button) return;
        button.addEventListener("click", async () => {
          const url = button.getAttribute("data-share-url") || window.location.href;
          if (navigator.clipboard?.writeText) {
            try {
              await navigator.clipboard.writeText(url);
              showShareToast(stateEl, "Copied!");
              return;
            } catch (error) {
              // fall through to manual copy prompt
            }
          }
          const ok = fallbackCopy(url);
          if (ok) {
            showShareToast(stateEl, "Copied!");
            return;
          }
          const manual = window.prompt("Sao ch√©p li√™n k·∫øt:", url);
          showShareToast(
            stateEl,
            manual !== null ? "Copied!" : "Kh√¥ng sao ch√©p ƒë∆∞·ª£c",
            manual !== null ? "success" : "error"
          );
        });
      };

      bindShareButton(shareBtn, shareState);
      bindShareButton(commentShareBtn, commentShareState);

      load();
    };

    initReactions();
    document.addEventListener("astro:page-load", initReactions);
  </script>
</BaseLayout>
