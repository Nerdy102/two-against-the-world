---
import BaseLayout from "../../layouts/BaseLayout.astro";
import FeedCard from "../../components/FeedCard.astro";
import RansomTitle from "../../components/RansomTitle.astro";
import { formatDate } from "../../lib/formatDate";
import { ensurePostMediaSchema, ensurePostsSchema, getDb, type PostRecord } from "../../lib/d1";
import {
  getPublishedPostsFromContent,
  mergePostsBySlug,
  resolvePostCoverUrl,
  shouldUseContentFallback,
} from "../../lib/posts";

export const prerender = false;

let posts: PostRecord[] = [];
let dbPosts: PostRecord[] = [];
try {
  const allowBootstrap = Astro.locals?.runtime?.env?.ALLOW_SCHEMA_BOOTSTRAP === "true";
  const db = getDb(Astro.locals);
  await ensurePostsSchema(db, { allowBootstrap });
  await ensurePostMediaSchema(db, { allowBootstrap });
  const { results = [] } = await db
    .prepare(
      `SELECT
        id,
        slug,
        title,
        summary,
        COALESCE(
          NULLIF(posts.cover_url, ''),
          (
            SELECT pm.url
            FROM post_media pm
            WHERE pm.post_id = posts.id
            ORDER BY pm.sort_order ASC, datetime(pm.created_at) ASC
            LIMIT 1
          )
        ) as cover_url,
        video_url,
        video_poster,
        topic,
        author_name,
        location,
        event_time,
        written_at,
        photo_time,
        tags_csv,
        published_at,
        created_at,
        CASE
          WHEN pinned = 1 AND (pinned_until IS NULL OR datetime(pinned_until) > datetime('now')) THEN 1
          ELSE 0
        END as pinned,
       pinned_priority, pinned_until, pinned_style, sort_order
       FROM posts
       WHERE status = 'published'
       ORDER BY pinned DESC, pinned_priority DESC, datetime(published_at) DESC`
    )
    .all<PostRecord>();
  dbPosts = results ?? [];
  if (shouldUseContentFallback()) {
    const contentPosts = await getPublishedPostsFromContent();
    posts = mergePostsBySlug(dbPosts, contentPosts);
  } else {
    posts = dbPosts;
  }
} catch (err) {
  console.warn("Using content posts fallback:", err);
  posts = await getPublishedPostsFromContent();
}

const POSTS_PER_PAGE = 15;
const pageParam = Number.parseInt(Astro.url.searchParams.get("page") ?? "1", 10);
const requestedPage = Number.isNaN(pageParam) ? 1 : pageParam;
const totalPages = Math.max(1, Math.ceil(posts.length / POSTS_PER_PAGE));
const currentPage = Math.min(Math.max(requestedPage, 1), totalPages);
const pagedPosts = posts.slice((currentPage - 1) * POSTS_PER_PAGE, currentPage * POSTS_PER_PAGE);
const pageNumbers = Array.from({ length: totalPages }, (_, index) => index + 1);

const pageHref = (page: number) => {
  const params = new URLSearchParams(Astro.url.searchParams);
  if (page <= 1) {
    params.delete("page");
  } else {
    params.set("page", String(page));
  }
  const query = params.toString();
  return query ? `${Astro.url.pathname}?${query}` : Astro.url.pathname;
};

const dateCounts: Record<string, number> = {};
for (const p of pagedPosts) {
  const dateKey = new Date(p.published_at ?? p.created_at).toISOString().slice(0, 10);
  dateCounts[dateKey] = (dateCounts[dateKey] ?? 0) + 1;
}

const seenDates = new Set<string>();
const dateStats = Object.entries(dateCounts)
  .map(([dateKey, count]) => ({
    dateKey,
    count,
    label: formatDate(dateKey),
  }))
  .sort((a, b) => b.dateKey.localeCompare(a.dateKey));

const buildSearchText = (post: PostRecord) =>
  [
    post.title,
    post.summary,
    post.author_name,
    post.location,
    post.event_time,
    post.written_at,
    post.photo_time,
    post.tags_csv,
    post.topic,
  ]
    .filter(Boolean)
    .join(" ")
    .slice(0, 640);
---

<BaseLayout title="Nh·∫≠t k√Ω" description="Kho l∆∞u nh·∫≠t k√Ω t√¨nh y√™u." active="entries">
  <main class="mx-auto max-w-7xl px-5 pb-24 pt-10">
    <section class="paper edge-torn p-6 sm:p-10" data-reveal>
      <div class="kicker text-xs text-black/50">L∆ØU TR·ªÆ</div>
      <RansomTitle text="Nh·∫≠t k√Ω" as="h1" class="text-[44px] sm:text-[56px]" />
      <p class="mt-3 text-black/60">B·∫•m v√†o b·ªã √°m ƒë·∫•y h√≠ h√≠ :p</p>

      <div class="journal-tools" id="journal-tools" data-reveal>
        <div class="journal-tools__panel">
          <div class="journal-tools__header">
            <span class="journal-tools__icon">üìì</span>
            <span>Nh·∫≠t k√Ω</span>
            <span class="journal-tools__hint">T√¨m ·∫£nh theo ng√†y & t·ª´ kho√°</span>
          </div>
          <div class="journal-tools__content">
            <div class="journal-tools__fields">
              <label class="journal-tools__field">
                <span>Ng√†y ƒëƒÉng</span>
                <input class="input" type="date" data-search-date />
              </label>
              <label class="journal-tools__field">
                <span>T·ª´ kho√°</span>
                <input
                  class="input"
                  type="search"
                  placeholder="T√¨m trong ti√™u ƒë·ªÅ / m√¥ t·∫£ / tag..."
                  data-search-keyword
                  data-search-primary
                />
              </label>
              <button class="btn journal-tools__reset" type="button" data-search-reset>ƒê·∫∑t l·∫°i</button>
            </div>
            <div class="journal-tools__stats">
              <div class="journal-tools__stats-title">Ng√†y ƒë√£ ƒëƒÉng</div>
              <ul class="journal-tools__stats-list">
                {dateStats.map((stat) => (
                  <li>
                    <a href={`#date-${stat.dateKey}`}>
                      <span>{stat.label}</span>
                      <span class="journal-tools__count">{stat.count} b√†i</span>
                    </a>
                  </li>
                ))}
              </ul>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="mt-10">
      <div class="pinterest-grid" data-search-grid>
        {pagedPosts.map((post) => {
          const dateKey = new Date(post.published_at ?? post.created_at).toISOString().slice(0, 10);
          const anchorId = seenDates.has(dateKey) ? undefined : `date-${dateKey}`;
          seenDates.add(dateKey);
          return (
            <FeedCard
              href={`/entries/${post.slug}${post.video_url ? "#entry-video" : ""}`}
              title={post.title}
              description={post.summary ?? ""}
              author={post.author_name ?? ""}
              date={post.published_at ?? ""}
              image={resolvePostCoverUrl(post)}
              topic={post.topic ?? undefined}
              locked={post.topic === "trash-bin"}
              pinned={Boolean(post.pinned)}
              pinnedStyle={post.pinned_style ?? undefined}
              dateKey={dateKey}
              anchorId={anchorId}
              searchText={buildSearchText(post)}
            />
          );
        })}
      </div>

      {posts.length > 0 && (
        <nav class="feed-pagination" aria-label="Ph√¢n trang nh·∫≠t k√Ω">
          <div class="feed-pagination__meta">Trang {currentPage} / {totalPages}</div>
          <div class="feed-pagination__row">
            <a
              class={`feed-pagination__arrow ${currentPage <= 1 ? "is-disabled" : ""}`}
              href={pageHref(Math.max(1, currentPage - 1))}
              aria-disabled={currentPage <= 1 ? "true" : "false"}
            >
              ‚Üê Trang tr∆∞·ªõc
            </a>
            <ol class="feed-pagination__list">
              {pageNumbers.map((page) => (
                <li>
                  <a class={`feed-pagination__page ${page === currentPage ? "is-active" : ""}`} href={pageHref(page)} aria-current={page === currentPage ? "page" : undefined}>
                    {page}
                  </a>
                </li>
              ))}
            </ol>
            <a
              class={`feed-pagination__arrow ${currentPage >= totalPages ? "is-disabled" : ""}`}
              href={pageHref(Math.min(totalPages, currentPage + 1))}
              aria-disabled={currentPage >= totalPages ? "true" : "false"}
            >
              Trang sau ‚Üí
            </a>
          </div>
        </nav>
      )}
    </section>
  </main>

  <script is:inline>
    const initSearch = () => {
      const dateInputs = Array.from(document.querySelectorAll("[data-search-date]"));
      const resets = Array.from(document.querySelectorAll("[data-search-reset]"));
      const cards = Array.from(document.querySelectorAll("[data-search-grid] .feed-card"));
      const keywordInput = document.querySelector("[data-search-keyword]");
      const primaryInput = document.querySelector("[data-search-primary]");
      const indexedCards = cards.map((card) => ({
        card,
        date: card.getAttribute("data-date") || "",
        haystack: (card.getAttribute("data-search") || "").toLowerCase(),
      }));

      if (!dateInputs.length || !resets.length || !indexedCards.length) return;
      if (dateInputs.some((input) => input.dataset.bound === "1")) return;
      dateInputs.forEach((input) => {
        input.dataset.bound = "1";
      });

      const syncDates = (value) => {
        dateInputs.forEach((input) => {
          if (input.value !== value) input.value = value;
        });
      };

      const filter = () => {
        const date = dateInputs[0]?.value ?? "";
        const keyword = keywordInput?.value?.trim().toLowerCase() ?? "";
        indexedCards.forEach(({ card, date: cardDate, haystack }) => {
          const matchesDate = date ? cardDate === date : true;
          const matchesKeyword = keyword ? haystack.includes(keyword) : true;
          card.classList.toggle("is-filtered", !(matchesDate && matchesKeyword));
        });
      };

      dateInputs.forEach((input) => {
        input.addEventListener("change", () => {
          syncDates(input.value);
          filter();
        });
      });

      let keywordDebounce = null;
      keywordInput?.addEventListener("input", () => {
        if (keywordDebounce) window.clearTimeout(keywordDebounce);
        keywordDebounce = window.setTimeout(filter, 300);
      });

      resets.forEach((reset) => {
        reset.addEventListener("click", () => {
          syncDates("");
          if (keywordInput) keywordInput.value = "";
          filter();
        });
      });

      const focusPrimary = () => {
        if (!primaryInput) return;
        primaryInput.scrollIntoView({ behavior: "smooth", block: "center" });
        primaryInput.focus();
        if (primaryInput.showPicker) primaryInput.showPicker();
      };

      const maybeFocusFromHash = () => {
        if (window.location.hash === "#journal-tools") {
          setTimeout(focusPrimary, 0);
        }
      };

      filter();
      maybeFocusFromHash();
      window.addEventListener("hashchange", maybeFocusFromHash);
    };

    initSearch();
    document.addEventListener("astro:page-load", initSearch);
  </script>
</BaseLayout>
